<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <title>
    
    Materiaali - Tietokantojen perusteet syksy 2023
    
  </title>
  <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        CommonHTML: {
          scale: 87
        }
      });
      </script>
  <script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  <link rel='stylesheet' type='text/css' media='screen' href=/syksy-2023/assets/css/main.css>
  <link rel='stylesheet' type='text/css' media='screen' href=/syksy-2023/assets/css/syntax.css>

  <script src=/syksy-2023/assets/js/main.js></script>

</head>


<body id="chapter">
    
<nav class="no-nav" id="side-nav" >
    <button id="hide" onclick="hideSideNav()"> &#x2715;</button>
    <button id="show" onclick="showSideNav()"> </button>
    <h2>Tietokantojen perusteet syksy 2023</h2>
    
    <ol>

        <li class="side-nav-obj" id="indexnav"><a href=/syksy-2023/index>Etusivu </a></li>
        
        
        
        <li class="side-nav-obj" id="Materiaalinav"><a href="/syksy-2023/pages/materiaali.html">Materiaali</a></li>
        
        
        
        
        
        <li class="side-nav-obj" id="Tehtävätnav"><a href="/syksy-2023/pages/tehtavat.html">Tehtävät</a></li>
        
        
        
        
        
        <li class="side-nav-obj" id="Tulokset ja palautenav"><a href="/syksy-2023/pages/tulokset_palaute.html">Tulokset ja palaute</a></li>
        
        
        <br>
        
        
        <li class="side-nav-obj" id="1. Johdantonav"><a href="/syksy-2023/content/osa-1/index.html">1. Johdanto</a></li>
        
        
            
            <li class="side-nav-sub-obj" id="Mikä on tietokantanav"><a href="/syksy-2023/content/osa-1/index.html#mikä-on-tietokanta">Mikä on tietokanta</a></li>
        
            
            <li class="side-nav-sub-obj" id="Tee-se-itse-tietokantanav"><a href="/syksy-2023/content/osa-1/index.html#tee-se-itse-tietokanta">Tee-se-itse-tietokanta</a></li>
        
            
            <li class="side-nav-sub-obj" id="Relaatiomalli ja SQL-kielinav"><a href="/syksy-2023/content/osa-1/index.html#relaatiomalli-ja-sql-kieli">Relaatiomalli ja SQL-kieli</a></li>
        
            
        
        
        
        
        <li class="side-nav-obj" id="2. SQL-kielen perusteetnav"><a href="/syksy-2023/content/osa-2/index.html">2. SQL-kielen perusteet</a></li>
        
        
            
            <li class="side-nav-sub-obj" id="Peruskomennotnav"><a href="/syksy-2023/content/osa-2/index.html#peruskomennot">Peruskomennot</a></li>
        
            
            <li class="side-nav-sub-obj" id="Yhteenveto ja ryhmittelynav"><a href="/syksy-2023/content/osa-2/index.html#yhteenveto-ja-ryhmittely">Yhteenveto ja ryhmittely</a></li>
        
            
            <li class="side-nav-sub-obj" id="SQLite-tietokantanav"><a href="/syksy-2023/content/osa-2/index.html#sqlite-tietokanta">SQLite-tietokanta</a></li>
        
            
        
        
        
        
        <li class="side-nav-obj" id="3. Monen taulun kyselytnav"><a href="/syksy-2023/content/osa-3/index.html">3. Monen taulun kyselyt</a></li>
        
        
            
            <li class="side-nav-sub-obj" id="Taulujen viittauksetnav"><a href="/syksy-2023/content/osa-3/index.html#taulujen-viittaukset">Taulujen viittaukset</a></li>
        
            
            <li class="side-nav-sub-obj" id="Liitostaulutnav"><a href="/syksy-2023/content/osa-3/index.html#liitostaulut">Liitostaulut</a></li>
        
            
            <li class="side-nav-sub-obj" id="JOIN-syntaksinav"><a href="/syksy-2023/content/osa-3/index.html#join-syntaksi">JOIN-syntaksi</a></li>
        
            
        
        
        
        
        <li class="side-nav-obj" id="4. Lisää SQL-kielestänav"><a href="/syksy-2023/content/osa-4/index.html">4. Lisää SQL-kielestä</a></li>
        
        
            
            <li class="side-nav-sub-obj" id="Tyypit ja lausekkeetnav"><a href="/syksy-2023/content/osa-4/index.html#tyypit-ja-lausekkeet">Tyypit ja lausekkeet</a></li>
        
            
            <li class="side-nav-sub-obj" id="NULL-arvotnav"><a href="/syksy-2023/content/osa-4/index.html#null-arvot">NULL-arvot</a></li>
        
            
            <li class="side-nav-sub-obj" id="Tulosrivien rajausnav"><a href="/syksy-2023/content/osa-4/index.html#tulosrivien-rajaus">Tulosrivien rajaus</a></li>
        
            
            <li class="side-nav-sub-obj" id="Alikyselytnav"><a href="/syksy-2023/content/osa-4/index.html#alikyselyt">Alikyselyt</a></li>
        
            
            <li class="side-nav-sub-obj" id="Lisää tekniikoitanav"><a href="/syksy-2023/content/osa-4/index.html#lisää-tekniikoita">Lisää tekniikoita</a></li>
        
            
        
        
        
        
        <li class="side-nav-obj" id="5. Tietokannat ohjelmoinnissanav"><a href="/syksy-2023/content/osa-5/index.html">5. Tietokannat ohjelmoinnissa</a></li>
        
        
            
            <li class="side-nav-sub-obj" id="Tietokannan käyttäminennav"><a href="/syksy-2023/content/osa-5/index.html#tietokannan-käyttäminen">Tietokannan käyttäminen</a></li>
        
            
            <li class="side-nav-sub-obj" id="Käyttöliittymänav"><a href="/syksy-2023/content/osa-5/index.html#käyttöliittymä">Käyttöliittymä</a></li>
        
            
            <li class="side-nav-sub-obj" id="Mitä tehdä missäkinnav"><a href="/syksy-2023/content/osa-5/index.html#mitä-tehdä-missäkin">Mitä tehdä missäkin</a></li>
        
            
        
        
        
        
        <li class="side-nav-obj" id="6. Tietokannan suunnittelunav"><a href="/syksy-2023/content/osa-6/index.html">6. Tietokannan suunnittelu</a></li>
        
        
            
            <li class="side-nav-sub-obj" id="Suunnittelun periaatteetnav"><a href="/syksy-2023/content/osa-6/index.html#suunnittelun-periaatteet">Suunnittelun periaatteet</a></li>
        
            
            <li class="side-nav-sub-obj" id="Tiedon atomisuusnav"><a href="/syksy-2023/content/osa-6/index.html#tiedon-atomisuus">Tiedon atomisuus</a></li>
        
            
            <li class="side-nav-sub-obj" id="Toisteinen tietonav"><a href="/syksy-2023/content/osa-6/index.html#toisteinen-tieto">Toisteinen tieto</a></li>
        
            
            <li class="side-nav-sub-obj" id="Suunnitteluesimerkkinav"><a href="/syksy-2023/content/osa-6/index.html#suunnitteluesimerkki">Suunnitteluesimerkki</a></li>
        
            
        
        
        
        
        <li class="side-nav-obj" id="7. Tietokannan ominaisuudetnav"><a href="/syksy-2023/content/osa-7/index.html">7. Tietokannan ominaisuudet</a></li>
        
        
            
            <li class="side-nav-sub-obj" id="Tiedon eheysnav"><a href="/syksy-2023/content/osa-7/index.html#tiedon-eheys">Tiedon eheys</a></li>
        
            
            <li class="side-nav-sub-obj" id="Transaktiotnav"><a href="/syksy-2023/content/osa-7/index.html#transaktiot">Transaktiot</a></li>
        
            
            <li class="side-nav-sub-obj" id="Kyselyjen suoritusnav"><a href="/syksy-2023/content/osa-7/index.html#kyselyjen-suoritus">Kyselyjen suoritus</a></li>
        
            
            <li class="side-nav-sub-obj" id="Indeksitnav"><a href="/syksy-2023/content/osa-7/index.html#indeksit">Indeksit</a></li>
        
            
        
        
        
        
        <li class="side-nav-obj" id="8. Tietokantojen teorianav"><a href="/syksy-2023/content/osa-8/index.html">8. Tietokantojen teoria</a></li>
        
        
            
            <li class="side-nav-sub-obj" id="Matemaattinen taustanav"><a href="/syksy-2023/content/osa-8/index.html#matemaattinen-tausta">Matemaattinen tausta</a></li>
        
            
            <li class="side-nav-sub-obj" id="Taulu relaationanav"><a href="/syksy-2023/content/osa-8/index.html#taulu-relaationa">Taulu relaationa</a></li>
        
            
            <li class="side-nav-sub-obj" id="Relaatio-operaatiotnav"><a href="/syksy-2023/content/osa-8/index.html#relaatio-operaatiot">Relaatio-operaatiot</a></li>
        
            
            <li class="side-nav-sub-obj" id="Avaimet ja riippuvuudetnav"><a href="/syksy-2023/content/osa-8/index.html#avaimet-ja-riippuvuudet">Avaimet ja riippuvuudet</a></li>
        
            
            <li class="side-nav-sub-obj" id="Normaalimuodotnav"><a href="/syksy-2023/content/osa-8/index.html#normaalimuodot">Normaalimuodot</a></li>
        
            
        
        
        
    </ol>
</nav>

    <div class="page-content">
        <div class="content">
    <div class="table-of-content" id="tof" style="display: none;">
    <ul>
        
    </ul>
</div>

    <h1 id="1-johdanto">1. Johdanto</h1>

<h2 id="mikä-on-tietokanta">Mikä on tietokanta</h2>

<p><em>Tietokanta</em> (<em>database</em>) on tietokoneella oleva kokoelma tietoa, johon voidaan suorittaa hakuja ja jonka sisältöä voidaan muuttaa. Tietokantoja ovat esimerkiksi:</p>

<ul>
  <li>nettisivuston käyttäjärekisteri</li>
  <li>verkkokaupan tuotteet ja varastotilanne</li>
  <li>pankin tiedot asiakkaista ja tilitapahtumista</li>
  <li>päivittäin mitatut säätiedot eri paikoissa</li>
  <li>lentoyhtiön lentoaikataulut ja varaustilanne</li>
</ul>

<p>Tietokantoja on nykyään valtavasti, ja useimmat ihmiset ovat tavallisen päivän aikana yhteydessä lukuisiin tietokantoihin.</p>

<h3 id="tietokantojen-haasteet">Tietokantojen haasteet</h3>

<p>Tietokantojen tekniseen toteutukseen liittyy monia haasteita, eikä hyvin toimivan tietokannan toteuttaminen ole helppo tehtävä. Keskeisiä haasteita ovat:</p>

<h4 id="tiedon-määrä">Tiedon määrä</h4>

<p>Monessa tietokannassa on suuri määrä tietoa, johon kohdistuu jatkuvasti hakuja ja muutoksia. Miten toteuttaa tietokanta niin, että tietoon pääsee käsiksi tehokkaasti?</p>

<h4 id="samanaikaisuus">Samanaikaisuus</h4>

<p>Tietokannalla on yleensä useita käyttäjiä, jotka voivat hakea ja muuttaa tietoa samaan aikaan.
Mitä tietokannan toteutuksessa tulee ottaa huomioon tähän liittyen?</p>

<h4 id="yllätykset">Yllätykset</h4>

<p>Tietokannan sisällön tulisi säilyä järkevänä myös yllättävissä tilanteissa. Esimerkiksi mitä tapahtuu, jos sähköt katkeavat juuri silloin, kun tietoa ollaan muuttamassa?</p>

<h3 id="tietokantajärjestelmät">Tietokantajärjestelmät</h3>

<p><em>Tietokantajärjestelmä</em> pitää huolta tietokannan sisällöstä ja tarjoaa tietokannan käyttäjälle toiminnot, joiden avulla tietoa pystyy hakemaan ja muuttamaan. Huomaa, että termiä <em>tietokanta</em> käytetään usein myös silloin, kun viitataan tietokantajärjestelmään.</p>

<p>Useimmat käytössä olevat tietokannat perustuvat relaatiomalliin ja SQL-kieleen, joihin tutustumme tällä kurssilla. Esimerkiksi MySQL, PostgreSQL ja SQLite ovat tällaisia tietokantajärjestelmiä. Näiden tietokantojen teoreettinen perusta syntyi 1970-luvulla.</p>

<p>Termi <em>NoSQL</em> viittaa tietokantaan, joka perustuu muuhun kuin relaatiomalliin ja SQL-kieleen. Esimerkiksi MongoDB ja Redis ovat saavuttaneet viime aikoina suosiota. Tällä kurssilla emme kuitenkaan juurikaan käsittele NoSQL-tietokantoja.</p>

<h2 id="tee-se-itse-tietokanta">Tee-se-itse-tietokanta</h2>

<p>Ennen tutustumista olemassa oleviin tietokantajärjestelmiin on hyvä miettiä, mitä tarvetta tällaisille järjestelmille on. Miksi emme voisi vain toteuttaa tietokantaa itse vaikkapa tallentamalla tietokannan sisällön tekstitiedostoon sopivassa muodossa?</p>

<h3 id="esimerkki">Esimerkki</h3>

<p>Haluamme tallentaa tietokantaan tietoa kurssin opiskelijoiden ratkaisuista kurssin tehtäviin. Kun opiskelija lähettää ratkaisun, tietokantaan tallennetaan opiskelijanumero, tehtävän numero, ratkaisun lähetysaika sekä ratkaisun tuottama pistemäärä.</p>

<p>Yksinkertainen tapa toteuttaa tietokanta on luoda yksi tekstitiedosto, jonka jokaisella rivillä on yksi lähetys. Aina kun joku opiskelija lähettää ratkaisun, tiedostoon lisätään yksi rivi. Voisimme käytännössä tallentaa tietokannan CSV-tiedostona tähän tapaan:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>012121212;1;2020-05-03 12:50:32;100
012341234;1;2020-05-03 14:02:12;100
012121212;2;2020-05-04 14:05:50;100
012121212;3;2020-05-04 14:43:12;0
012341234;2;2020-05-04 10:15:23;0
012341234;2;2020-05-04 16:40:39;0
013371337;1;2020-05-06 18:11:13;0
012341234;2;2020-05-07 10:02:15;100
</code></pre></div></div>

<p>CSV-tiedostossa tietty erotinmerkki erottaa riveillä olevat kentät. Tässä tapauksessa erotinmerkkinä on puolipiste <code class="language-html highlighter-rouge">;</code>. Esimerkiksi tiedoston ensimmäinen rivi kertoo, että opiskelija 012121212 on lähettänyt ratkaisun tehtävään 1 ja saanut siitä 100 pistettä.</p>

<p>Nyt jos haluamme vaikkapa selvittää jokaisen opiskelijan lähetysten määrän, voimme hoitaa asian näin Python-kielellä:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">count</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s">"lahetykset.csv"</span><span class="p">):</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">";"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">count</span><span class="p">:</span>
        <span class="n">count</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">count</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">print</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
</code></pre></div></div>

<p>Ohjelma antaa seuraavan tuloksen:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>{'012121212': 3, '012341234': 4, '013371337': 1}
</code></pre></div></div>

<p>Tämä tarkoittaa, että opiskelija 012121212 on lähettänyt kolme ratkaisua, opiskelija 012341234 on lähettänyt neljä ratkaisua ja opiskelija 013371337 on lähettänyt yhden ratkaisun.</p>

<h3 id="mahdolliset-ongelmat">Mahdolliset ongelmat</h3>

<p>Tällainen CSV-tiedostoa käyttävä tietokanta on periaatteessa toimiva, mutta sen käyttäminen voi johtaa ongelmiin:</p>

<h4 id="tiedon-määrä-1">Tiedon määrä</h4>

<p>Kun tiedon määrä kasvaa, tiedon hakeminen CSV-tiedostosta voi muodostua ongelmaksi. Tämä johtuu siitä, että joudumme useimmissa tilanteissa käymään läpi koko tiedoston sisällön alusta loppuun, kun haluamme saada haettua tietyn asian.</p>

<p>Esimerkiksi jos haluamme selvittää, minkä pistemäärän opiskelija 012341234 on saanut tehtävästä 2, joudumme käymään läpi tiedoston <em>kaikki</em> rivit, jotta löydämme oikeat rivit. Joudumme tekemään näin, koska rivit ovat sekalaisessa järjestyksessä eikä meillä ole etukäteen tietoa, missä haluamamme rivit ovat.</p>

<p>Tiedoston läpikäynti ei ole ongelma, jos tiedosto on pieni. Esimerkiksi jos tiedostossa on sata riviä, läpikäynti sujuu hyvin nopeasti. Mutta tiedoston koon kasvaessa alkaa olla työlästä käydä kaikki rivit läpi aina, kun haluamme saada selville jotain tiedostosta.</p>

<h4 id="samanaikaisuus-1">Samanaikaisuus</h4>

<p>Mitä tapahtuu, jos kaksi opiskelijaa lähettävät ratkaisun samaan aikaan? Tällöin tiedoston loppuun pitäisi tulla kaksi riviä tietoa seuraavaan tapaan:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>012341234;3;2020-05-07 15:42:02;0
013371337;7;2020-05-07 15:42:02;0
</code></pre></div></div>

<p>Jos käy huonosti, voi kuitenkin käydä näin:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>012341234;3;2020013371337;7;2020-05-07 15:42:02;0
-05-07 15:42:02;0
</code></pre></div></div>

<p>Tässä ensimmäinen prosessi kirjoittaa ensin tiedoston loppuun <code class="language-html highlighter-rouge">012341234;3;2020</code>, sitten toinen prosessi kirjoittaa väliin <code class="language-html highlighter-rouge">013371337;7;2020-05-07 15:42:02;0</code> ja lopuksi ensimmäinen prosessi kirjoittaa <code class="language-html highlighter-rouge">-05-07 15:42:02;0</code>. Tämän seurauksena tiedoston rakenne menee sekaisin.</p>

<p>Kun tiedostoon kirjoitetaan tietoa, ei ole itsestään selvää, että tieto menee perille yhtenäisenä, jos joku muu koettaa kirjoittaa samaan aikaan. Tämä riippuu tiedostojärjestelmästä, tiedon määrästä ja tiedoston käsittelytavasta.</p>

<h4 id="yllätykset-1">Yllätykset</h4>

<p>Tarkastellaan tilannetta, jossa haluamme poistaa tietokannasta opiskelijan 012341234 lähetykset. Voimme tehdä tämän lukemalla ensin kaikki rivit muistiin ja kirjoittamalla sitten takaisin
tiedostoon kaikki rivit, joissa opiskelija ei ole 012341234.</p>

<p>Mitä jos sähköt katkeavat juuri, kun olemme kirjoittaneet puolet riveistä takaisin? Kun käynnistämme tietokannan uudestaan, huomaamme, että tiedostossa on vain puolet riveistä ja loput ovat kadonneet eikä meillä ole keinoa saada niitä takaisin.</p>

<h3 id="mitä-opimme-tästä">Mitä opimme tästä?</h3>

<p>Yksinkertainen tekstitiedosto ei ole sinänsä huono tapa tallentaa tietoa, mutta se ei sovellu kaikkiin käyttötarkoituksiin. Tämän vuoksi tarvitsemme erillisiä tietokantajärjestelmiä, joihin tutustumme tällä kurssilla.</p>

<p>Tietokantajärjestelmien kehittäjät ovat miettineet tarkasti, miten järjestelmä kannattaa toteuttaa, jotta tietoon pääsee käsiksi tehokkaasti, samanaikaiset käyttäjät eivät aiheuta ongelmia eikä tietoa katoa yllättävissä tilanteissa. Kun käytämme tietokantajärjestelmää, meidän ei tarvitse huolehtia tästä kaikesta itse.</p>

<h2 id="relaatiomalli-ja-sql-kieli">Relaatiomalli ja SQL-kieli</h2>

<p>Tällä kurssilla tutustumme tietokantoihin relaatiomallin ja SQL-kielen kautta. Relaatiomallin ytimessä on kaksi perusideaa:</p>

<ol>
  <li>Kaikki tieto tallennetaan tauluihin riveinä, jotka voivat viitata toisiinsa.</li>
  <li>Tietokannan käyttäjä käsittelee tietoa SQL-kielellä, joka kätkee käyttäjältä tietokannan sisäisen toiminnan yksityiskohdat.</li>
</ol>

<h3 id="tietokannan-rakenne">Tietokannan rakenne</h3>

<p>Relaatiomallissa tietokanta muodostuu <em>tauluista</em> (<em>table</em>), joissa on kiinteät <em>sarakkeet</em> (<em>column</em>). Tauluihin tallennetaan tietoa <em>riveinä</em> (<em>row</em>), joilla on tietyt arvot sarakkeissa. Jokaisessa taulussa on kokoelma tiettyyn asiaan liittyvää tietoa.</p>

<p>Seuraavassa kuvassa on esimerkki tietokannasta, jota voisi käyttää osana verkkokaupan toteutusta. Tauluissa <code class="language-html highlighter-rouge">Tuotteet</code>, <code class="language-html highlighter-rouge">Asiakkaat</code> ja <code class="language-html highlighter-rouge">Ostokset</code> on tietoa tuotteista, asiakkaista ja heidän ostoskoriensa sisällöstä.</p>

<table class="db-table">
<thead>
  <tr><th colspan="3" id="table-title">Tuotteet</th></tr>
  <tr><th width="30">id</th><th width="100">nimi</th><th width="70">hinta</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>retiisi</td><td>7</td></tr>
  <tr><td>2</td><td>porkkana</td><td>5</td></tr>
  <tr><td>3</td><td>nauris</td><td>4</td></tr>
  <tr><td>4</td><td>lanttu</td><td>8</td></tr>
  <tr><td>5</td><td>selleri</td><td>4</td></tr>
</tbody>
</table>

<table class="db-table">
<thead>
  <tr><th colspan="2" id="table-title">Asiakkaat</th></tr>
  <tr><th width="30">id</th><th width="100">nimi</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>Uolevi</td></tr>
  <tr><td>2</td><td>Maija</td></tr>
  <tr><td>3</td><td>Aapeli</td></tr>
</tbody>
</table>

<table class="db-table">
<thead>
  <tr><th colspan="2" id="table-title">Ostokset</th></tr>
  <tr><th width="100">asiakas_id</th><th width="100">tuote_id</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>2</td></tr>
  <tr><td>1</td><td>5</td></tr>
  <tr><td>2</td><td>1</td></tr>
  <tr><td>2</td><td>4</td></tr>
  <tr><td>2</td><td>5</td></tr>
</tbody>
</table>

<p>Tauluissa <code class="language-html highlighter-rouge">Tuotteet</code> ja <code class="language-html highlighter-rouge">Asiakkaat</code> jokaisella rivillä on yksilöllinen id-numero, jonka avulla niihin voi viitata. Tämä on yleinen tapa tietokantojen suunnittelussa. Tämän ansiosta taulussa <code class="language-html highlighter-rouge">Ostokset</code> voidaan esittää id-numeroiden avulla, mitä tuotteita kukin asiakas on valinnut. Tässä esimerkissä Uolevin korissa on porkkana ja selleri ja Maijan korissa on retiisi, lanttu ja selleri.</p>

<h3 id="sql-kieli">SQL-kieli</h3>

<p><em>SQL</em> (<em>Structured Query Language</em>) on vakiintunut tapa käsitellä tietokannan sisältöä.
Kielessä on komentoja, joiden avulla tietokannan käyttäjä (esimerkiksi tietokantaa käyttävä ohjelmoija) voi lisätä, hakea, muuttaa ja poistaa tietoa.</p>

<p>SQL-komennot muodostuvat avainsanoista (kuten <code class="language-html highlighter-rouge">SELECT</code> ja <code class="language-html highlighter-rouge">WHERE</code>), taulujen ja sarakkeiden nimistä sekä muista arvoista. Esimerkiksi komento</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">hinta</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">WHERE</span> <span class="n">nimi</span><span class="o">=</span><span class="s1">'retiisi'</span><span class="p">;</span>
</code></pre></div></div>

<p>hakee tietokannan tuotteista retiisin hinnan. Komentojen lopussa on puolipiste <code class="language-html highlighter-rouge">;</code> ja voimme käyttää välilyöntejä ja rivinvaihtoja haluamallamme tavalla. Esimerkiksi voisimme kirjoittaa äskeisen komennon myös näin usealle riville:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">hinta</span>
<span class="k">FROM</span>
  <span class="n">Tuotteet</span>
<span class="k">WHERE</span>
  <span class="n">nimi</span><span class="o">=</span><span class="s1">'retiisi'</span><span class="p">;</span>
</code></pre></div></div>

<p>Tutustumme SQL-kieleen tarkemmin materiaalin luvuissa 2–4.</p>

<p>SQL-kieli syntyi 1970-luvulla, ja siinä on paljon muistumia <em>vanhan ajan ohjelmoinnista</em>.
Tällaisia piirteitä ovat esimerkiksi:</p>

<ul>
  <li>Avainsanat ovat kokonaisia englannin kielen sanoja, ja komennot muistuttavat englannin kielen lauseita.</li>
  <li>Avainsanoissa kirjainkoolla ei ole väliä. Esimerkiksi <code class="language-html highlighter-rouge">SELECT</code>, <code class="language-html highlighter-rouge">select</code> ja <code class="language-html highlighter-rouge">Select</code> tarkoittavat samaa. Avainsanat on tapana kirjoittaa kokonaan suurilla kirjaimilla.</li>
  <li>Merkki <code class="language-html highlighter-rouge">=</code> tarkoittaa sekä asetusta että yhtäsuuruusvertailua (nykyään ohjelmoinnissa yhtäsuuruusvertailu on yleensä <code class="language-html highlighter-rouge">==</code>).</li>
</ul>

<p>SQL-kielestä on olemassa <em>standardeja</em>, jotka pyrkivät antamaan yhteisen pohjan kielelle. Käytännössä jokainen SQL-kielen toteutus toimii kuitenkin hieman omalla tavallaan. Tällä kurssilla keskitymme SQL:n ominaisuuksiin, jotka ovat yleisesti käytettävissä eri tietokannoissa.</p>

<h3 id="tietokannan-sisäinen-toiminta">Tietokannan sisäinen toiminta</h3>

<p>Tietokantajärjestelmän tehtävänä on käsitellä käyttäjän antamat SQL-komennot. Esimerkiksi kun käyttäjä antaa komennon, joka hakee tietoa tietokannasta, tietokantajärjestelmän tulee löytää jokin hyvä tapa käsitellä komento ja toimittaa tulokset takaisin käyttäjälle mahdollisimman nopeasti.</p>

<p>SQL-kielen hienoutena on, että käyttäjän riittää <em>kuvailla</em>, mitä tietoa hän haluaa, minkä jälkeen tietokantajärjestelmä hoitaa likaisen työn ja hankkii tiedot tietokannan uumenista. Tämä on mukavaa käyttäjälle, koska hänen ei tarvitse tietää mitään tietokannan sisäisestä toiminnasta
vaan voi luottaa tietokantajärjestelmään.</p>

<p>Tietokantajärjestelmän toteuttaminen on vaikea tehtävä, koska järjestelmän täytyy sekä osata käsitellä tehokkaasti SQL-komentoja että huolehtia siitä, että kaikki toimii oikein samanaikaisilla käyttäjillä ja yllättävissä tilanteissa. Tällä kurssilla tutustumme tietokantoihin lähinnä tietokannan käyttäjän näkökulmasta emmekä perehdy niiden sisäiseen toimintaan.</p>

<h1 id="2-sql-kielen-perusteet">2. SQL-kielen perusteet</h1>

<h2 id="peruskomennot">Peruskomennot</h2>

<p>Tässä luvussa tutustumme tavallisimpiin SQL-komentoihin, joiden avulla voimme lisätä, hakea, muuttaa ja poistaa tietokannan sisältöä. Nämä komennot muodostavat perustan tietokannan käyttämiselle.</p>

<h3 id="taulun-luonti">Taulun luonti</h3>

<p>Komento <code class="language-html highlighter-rouge">CREATE TABLE</code> luo taulun, jossa on halutut sarakkeet. Esimerkiksi seuraava komento luo taulun <code class="language-html highlighter-rouge">Tuotteet</code>, jossa on kolme saraketta:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="n">nimi</span> <span class="nb">TEXT</span><span class="p">,</span> <span class="n">hinta</span> <span class="nb">INTEGER</span><span class="p">);</span>
</code></pre></div></div>

<p>Voimme nimetä taulun ja sarakkeet haluamallamme tavalla. Tällä kurssilla käytäntönä on, että kirjoitamme taulun nimen suurella alkukirjaimella ja monikkomuotoisena. Sarakkeiden nimet puolestaan kirjoitamme pienellä alkukirjaimella.</p>

<p>Jokaisesta sarakkeesta ilmoitetaan nimen lisäksi tyyppi. Tässä taulussa sarakkeet <code class="language-html highlighter-rouge">id</code> ja <code class="language-html highlighter-rouge">hinta</code> ovat kokonaislukuja (<code class="language-html highlighter-rouge">INTEGER</code>) ja sarake <code class="language-html highlighter-rouge">nimi</code> on merkkijono (<code class="language-html highlighter-rouge">TEXT</code>). Sarake <code class="language-html highlighter-rouge">id</code> on lisäksi taulun <em>pääavain</em> (<code class="language-html highlighter-rouge">PRIMARY KEY</code>), mikä tarkoittaa, että se yksilöi jokaisen taulun rivin ja voimme viitata sen avulla kätevästi mihin tahansa riviin.</p>

<h4 id="pääavain">Pääavain</h4>

<p>Tietokannan taulun <em>pääavain</em> on jokin sarake (tai sarakkeiden yhdistelmä), joka yksilöi taulun jokaisen rivin eli millään kahdella rivillä ei ole samaa pääavainta. Käytännössä hyvin tavallinen valinta pääavaimeksi on kokonaislukumuotoinen id-numero.</p>

<p>Usein haluamme lisäksi, että id-numerolla on <em>juokseva numerointi</em>. Tämä tarkoittaa, että kun tauluun lisätään rivejä, ensimmäinen rivi saa automaattisesti id-numeron 1, toinen rivi saa id-numeron 2, jne. Juoksevan numeroinnin toteuttaminen riippuu tietokantajärjestelmästä. Esimerkiksi SQLite-tietokannassa <code class="language-html highlighter-rouge">INTEGER PRIMARY KEY</code> -tyyppinen sarake saa automaattisesti juoksevan numeroinnin.</p>

<h3 id="tiedon-lisääminen">Tiedon lisääminen</h3>

<p>Komento <code class="language-html highlighter-rouge">INSERT</code> lisää uuden rivin tauluun. Esimerkiksi seuraava komento lisää rivin äsken luomaamme tauluun <code class="language-html highlighter-rouge">Tuotteet</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">nimi</span><span class="p">,</span><span class="n">hinta</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'retiisi'</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
</code></pre></div></div>

<p>Tässä annamme arvot lisättävän rivin sarakkeille <code class="language-html highlighter-rouge">nimi</code> ja <code class="language-html highlighter-rouge">hinta</code>. Kun sarakkeessa <code class="language-html highlighter-rouge">id</code> on juokseva numerointi, se saa automaattisesti arvon 1, kun kyseessä on taulun ensimmäinen rivi. Niinpä tauluun ilmestyy seuraava rivi:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        hinta     
----------  ----------  ----------
1           retiisi     7         
</code></pre></div></div>

<p>Jos emme anna arvoa jollekin sarakkeelle, se saa oletusarvon. Tavallisessa sarakkeessa oletusarvo on <code class="language-html highlighter-rouge">NULL</code>, mikä tarkoittaa tiedon puuttumista. Esimerkiksi seuraavassa komennossa emme anna arvoa sarakkeelle <code class="language-html highlighter-rouge">hinta</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">nimi</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'retiisi'</span><span class="p">);</span>
</code></pre></div></div>

<p>Tällöin tauluun ilmestyy rivi, jossa hinta on <code class="language-html highlighter-rouge">NULL</code> (eli tyhjä):</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        hinta     
----------  ----------  ----------
1           retiisi     
</code></pre></div></div>

<h3 id="esimerkkitaulu">Esimerkkitaulu</h3>

<p>Oletamme tämän osion tulevissa esimerkeissä, että olemme lisänneet tauluun <code class="language-html highlighter-rouge">Tuotteet</code> seuraavat viisi riviä:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">nimi</span><span class="p">,</span><span class="n">hinta</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'retiisi'</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">nimi</span><span class="p">,</span><span class="n">hinta</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'porkkana'</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">nimi</span><span class="p">,</span><span class="n">hinta</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'nauris'</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">nimi</span><span class="p">,</span><span class="n">hinta</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'lanttu'</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">nimi</span><span class="p">,</span><span class="n">hinta</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'selleri'</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
</code></pre></div></div>

<p>Taulun sisältö on siis seuraavanlainen:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        hinta     
----------  ----------  ----------
1           retiisi     7         
2           porkkana    5         
3           nauris      4         
4           lanttu      8         
5           selleri     4         
</code></pre></div></div>

<h3 id="tiedon-hakeminen">Tiedon hakeminen</h3>

<p>Komento <code class="language-html highlighter-rouge">SELECT</code> suorittaa <em>kyselyn</em> eli hakee tietoa taulusta. Yksinkertaisin tapa tehdä kysely on hakea kaikki tiedot taulusta:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span><span class="p">;</span>
</code></pre></div></div>

<p>Tässä tapauksessa kyselyn tulos on seuraava:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        hinta     
----------  ----------  ----------
1           retiisi     7         
2           porkkana    5         
3           nauris      4         
4           lanttu      8         
5           selleri     4         
</code></pre></div></div>

<p>Kyselyssä tähti <code class="language-html highlighter-rouge">*</code> ilmaisee, että haluamme hakea kaikki sarakkeet. Kuitenkin voimme myös hakea vain osan sarakkeista. Esimerkiksi seuraava kysely hakee vain tuotteiden nimet:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">nimi</span> <span class="k">FROM</span> <span class="n">Tuotteet</span><span class="p">;</span>
</code></pre></div></div>

<p>Kyselyn tulos on seuraava:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi      
----------
retiisi    
porkkana             
nauris               
lanttu               
selleri              
</code></pre></div></div>

<p>Tämä kysely puolestaan hakee nimet ja hinnat:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">nimi</span><span class="p">,</span> <span class="n">hinta</span> <span class="k">FROM</span> <span class="n">Tuotteet</span><span class="p">;</span>
</code></pre></div></div>

<p>Nyt kyselyn tulos muuttuu näin:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi        hinta     
----------  ----------
retiisi     7         
porkkana    5         
nauris      4         
lanttu      8         
selleri     4         
</code></pre></div></div>

<p>Kyselyn tuloksena olevat rivit muodostavat taulun, jota kutsutaan nimellä <em>tulostaulu</em>. Sen sarakkeet ja rivit riippuvat kyselyn sisällöstä. Esimerkiksi äskeinen kysely loi tulostaulun, jossa on kaksi saraketta ja viisi riviä.</p>

<p>Tietokannan käsittelyssä esiintyy siis kahdenlaisia tauluja: tietokannassa kiinteästi olevia tauluja, joihin on tallennettu tietokannan sisältö, sekä kyselyjen muodostamia väliaikaisia tulostauluja, joiden tiedot on koostettu kiinteistä tauluista.</p>

<h4 id="hakuehto">Hakuehto</h4>

<p>Liittämällä <code class="language-html highlighter-rouge">SELECT</code>-kyselyyn <code class="language-html highlighter-rouge">WHERE</code>-osan voimme valita vain osan riveistä halutun ehdon perusteella. Esimerkiksi seuraava kysely hakee tiedot lantusta:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">WHERE</span> <span class="n">nimi</span><span class="o">=</span><span class="s1">'lanttu'</span><span class="p">;</span>
</code></pre></div></div>

<p>Kyselyn tulos on seuraava:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        hinta     
----------  ----------  ----------
4           lanttu      8        
</code></pre></div></div>

<p>Ehdoissa voi käyttää vertailuja ja sanoja <code class="language-html highlighter-rouge">AND</code> ja <code class="language-html highlighter-rouge">OR</code> samaan tapaan kuin ohjelmoinnissa. Esimerkiksi seuraava kysely etsii tuotteet, joiden hinta on välillä 4…6:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">WHERE</span> <span class="n">hinta</span><span class="o">&gt;=</span><span class="mi">4</span> <span class="k">AND</span> <span class="n">hinta</span><span class="o">&lt;=</span><span class="mi">6</span><span class="p">;</span>
</code></pre></div></div>

<p>Kyselyn tulos on seuraava:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        hinta     
----------  ----------  ----------
2           porkkana    5         
3           nauris      4         
5           selleri     4         
</code></pre></div></div>

<h4 id="järjestäminen">Järjestäminen</h4>

<p>Oletuksena kyselyn tuloksena olevien rivien järjestys voi olla mikä tahansa. Voimme kuitenkin määrittää halutun järjestyksen <code class="language-html highlighter-rouge">ORDER BY</code> -osan avulla. Esimerkiksi seuraava kysely hakee tuotteet järjestyksessä nimen mukaan:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">nimi</span><span class="p">;</span>
</code></pre></div></div>

<p>Kyselyn tulos on seuraava:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        hinta     
----------  ----------  ----------
4           lanttu      8         
3           nauris      4         
2           porkkana    5         
1           retiisi     7         
5           selleri     4  
</code></pre></div></div>

<p>Järjestys on oletuksena pienimmästä suurimpaan. Kuitenkin jos haluamme järjestyksen suurimmasta pienimpään, voimme lisätä sanan <code class="language-html highlighter-rouge">DESC</code> sarakkeen nimen jälkeen:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">nimi</span> <span class="k">DESC</span><span class="p">;</span>
</code></pre></div></div>

<p>Tämän seurauksena kyselyn tulos on seuraava:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        hinta     
----------  ----------  ----------
5           selleri     4  
1           retiisi     7         
2           porkkana    5         
3           nauris      4         
4           lanttu      8         
</code></pre></div></div>

<p>Tietokantakielessä järjestys on joko <em>nouseva</em> (<em>ascending</em>) eli pienimmästä suurimpaan tai <em>laskeva</em> (<em>descending</em>) eli suurimmasta pienimpään. Oletuksena järjestys on nouseva, ja avainsana <code class="language-html highlighter-rouge">DESC</code> tarkoittaa siis laskevaa järjestystä.</p>

<p>SQL-kielessä on myös avainsana <code class="language-html highlighter-rouge">ASC</code>, joka tarkoittaa nousevaa järjestystä. Seuraavat kyselyt toimivat siis samalla tavalla:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">nimi</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">nimi</span> <span class="k">ASC</span><span class="p">;</span>
</code></pre></div></div>

<p>Käytännössä sanaa <code class="language-html highlighter-rouge">ASC</code> käytetään kuitenkin äärimmäisen harvoin.</p>

<p>Voimme myös järjestää rivejä usealla eri perusteella. Esimerkiksi seuraava kysely järjestää rivit ensisijaisesti kalleimmasta halvimpaan hinnan mukaan ja toissijaisesti aakkosjärjestykseen nimen mukaan:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">hinta</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">nimi</span><span class="p">;</span>
</code></pre></div></div>

<p>Kyselyn tulos on seuraava:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        hinta     
----------  ----------  ----------
4           lanttu      8         
1           retiisi     7         
2           porkkana    5         
3           nauris      4         
5           selleri     4  
</code></pre></div></div>

<p>Tässä tapauksessa nauris ja selleri järjestetään nimen mukaan, koska ne ovat yhtä kalliita.</p>

<h4 id="erilliset-tulosrivit">Erilliset tulosrivit</h4>

<p>Joskus tulostaulussa voi olla useita samanlaisia rivejä. Näin käy esimerkiksi seuraavassa kyselyssä:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">hinta</span> <span class="k">FROM</span> <span class="n">Tuotteet</span><span class="p">;</span>
</code></pre></div></div>

<p>Koska kahden tuotteen hinta on 4, kahden tulosrivin sisältönä on 4:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>hinta     
----------
7         
5         
4         
8         
4         
</code></pre></div></div>

<p>Jos kuitenkin haluamme vain erilaiset tulosrivit, voimme lisätä kyselyyn sanan <code class="language-html highlighter-rouge">DISTINCT</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">hinta</span> <span class="k">FROM</span> <span class="n">Tuotteet</span><span class="p">;</span>
</code></pre></div></div>

<p>Tämän seurauksena kyselyn tulos muuttuu näin:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>hinta     
----------
7         
5         
4         
8         
</code></pre></div></div>

<h3 id="tiedon-muuttaminen">Tiedon muuttaminen</h3>

<p>Komento <code class="language-html highlighter-rouge">UPDATE</code> muuttaa taulun rivejä, jotka täsmäävät haluttuun ehtoon. Esimerkiksi seuraava komento muuttaa tuotteen 2 hinnaksi 6:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">UPDATE</span> <span class="n">Tuotteet</span> <span class="k">SET</span> <span class="n">hinta</span><span class="o">=</span><span class="mi">6</span> <span class="k">WHERE</span> <span class="n">id</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<p>Useita sarakkeita voi muuttaa yhdistämällä muutokset pilkuilla. Esimerkiksi seuraava komento muuttaa tuotteen 2 nimeksi ananas ja hinnaksi 9:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">UPDATE</span> <span class="n">Tuotteet</span> <span class="k">SET</span> <span class="n">nimi</span><span class="o">=</span><span class="s1">'ananas'</span><span class="p">,</span> <span class="n">hinta</span><span class="o">=</span><span class="mi">9</span> <span class="k">WHERE</span> <span class="n">id</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<p>Muutos voidaan myös laskea aiemman arvon perusteella. Esimerkiksi seuraava komento kasvattaa tuotteen 2 hintaa yhdellä:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">UPDATE</span> <span class="n">Tuotteet</span> <span class="k">SET</span> <span class="n">hinta</span><span class="o">=</span><span class="n">hinta</span><span class="o">+</span><span class="mi">1</span> <span class="k">WHERE</span> <span class="n">id</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<p>Jos komennossa ei ole ehtoa, se vaikuttaa <em>kaikkiin</em> riveihin. Esimerkiksi seuraava komento kasvattaa jokaisen tuotteen hintaa yhdellä:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">UPDATE</span> <span class="n">Tuotteet</span> <span class="k">SET</span> <span class="n">hinta</span><span class="o">=</span><span class="n">hinta</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="tiedon-poistaminen">Tiedon poistaminen</h3>

<p>Komento <code class="language-html highlighter-rouge">DELETE</code> poistaa taulusta rivit, jotka täsmäävät annettuun ehtoon. Esimerkiksi seuraava komento poistaa taulusta tuotteen 5:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">WHERE</span> <span class="n">id</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>
</code></pre></div></div>

<p>Kuten muuttamisessa, jos ehtoa ei ole, niin komento vaikuttaa kaikkiin riveihin. Seuraava komento siis poistaa <em>kaikki</em> tuotteet taulusta:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">Tuotteet</span><span class="p">;</span>
</code></pre></div></div>

<p>Komento <code class="language-html highlighter-rouge">DROP TABLE</code> poistaa tietokannan taulun (ja kaiken sen sisällön). Esimerkiksi seuraava komento poistaa taulun <code class="language-html highlighter-rouge">Tuotteet</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">Tuotteet</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="yhteenveto-ja-ryhmittely">Yhteenveto ja ryhmittely</h2>

<p>Yhteenvetokysely laskee jonkin yksittäisen arvon taulun riveistä, kuten taulun rivien määrän tai sarakkeen kaikkien arvojen summan. Tällaisen kyselyn tulostaulussa on vain yksi rivi.</p>

<p>Yhteenvetokyselyn perustana on <em>koostefunktio</em>, joka laskee yhteenvetoarvon taulun riveistä. Tavallisimmat koostefunktiot ovat seuraavat:</p>

<ul>
  <li><code class="language-html highlighter-rouge">COUNT()</code> laskee rivien määrän</li>
  <li><code class="language-html highlighter-rouge">SUM()</code> laskee summan arvoista</li>
  <li><code class="language-html highlighter-rouge">MIN()</code> hakee pienimmän arvon</li>
  <li><code class="language-html highlighter-rouge">MAX()</code> hakee suurimman arvon</li>
</ul>

<h3 id="esimerkkejä">Esimerkkejä</h3>

<p>Tarkastellaan taas taulua <code class="language-html highlighter-rouge">Tuotteet</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        hinta     
----------  ----------  ----------
1           retiisi     7         
2           porkkana    5         
3           nauris      4         
4           lanttu      8         
5           selleri     4         
</code></pre></div></div>

<p>Seuraava kysely hakee taulun rivien määrän:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tuotteet</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>COUNT(*)
----------
5
</code></pre></div></div>

<p>Seuraava kysely hakee niiden rivien määrän, joissa hinta on 4:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">WHERE</span> <span class="n">hinta</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>COUNT(*)
----------
2
</code></pre></div></div>

<p>Seuraava kysely puolestaan laskee summan tuotteiden hinnoista:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">hinta</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tuotteet</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>SUM(hinta)
----------
28
</code></pre></div></div>

<h3 id="rivien-valinta">Rivien valinta</h3>

<p>Jos <code class="language-html highlighter-rouge">COUNT</code>-funktion sisällä on tähti <code class="language-html highlighter-rouge">*</code>, kysely laskee kaikki rivit. Jos taas funktion sisällä on sarakkeen nimi, kysely laskee rivit, joissa sarakkeessa on arvo (eli sarake ei ole <code class="language-html highlighter-rouge">NULL</code>).</p>

<p>Tarkastellaan esimerkkinä seuraavaa taulua, jossa rivillä 3 ei ole hintaa:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        hinta     
----------  ----------  ----------
1           retiisi     7         
2           nauris      4         
3           lanttu               
4           selleri     4         
</code></pre></div></div>

<p>Seuraava kysely hakee rivien yhteismäärän:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tuotteet</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>COUNT(*)  
----------
4
</code></pre></div></div>

<p>Seuraava kysely taas hakee niiden rivien määrän, joilla on hinta:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">hinta</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tuotteet</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>COUNT(hinta)
------------
3
</code></pre></div></div>

<p>Voimme myös käyttää sanaa <code class="language-html highlighter-rouge">DISTINCT</code>, jotta saamme laskettua, montako eri arvoa jossakin sarakkeessa on:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">hinta</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tuotteet</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>COUNT(DISTINCT hinta)
---------------------
2
</code></pre></div></div>

<h3 id="ryhmittely">Ryhmittely</h3>

<p>Ryhmittelyn avulla voimme yhdistää rivikohtaista ja koostefunktion antamaa tietoa. Ideana on, että rivit jaetaan ryhmiin <code class="language-html highlighter-rouge">GROUP BY</code> -osassa annettujen sarakkeiden mukaan ja tämän jälkeen koostefunktion arvo lasketaan jokaiselle ryhmälle erikseen.</p>

<h4 id="esimerkki-1">Esimerkki</h4>

<p>Tarkastellaan esimerkkinä seuraavaa taulua <code class="language-html highlighter-rouge">Tyontekijat</code>, jossa on työntekijöiden tietoja:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        yritys      palkka    
----------  ----------  ----------  ----------
1           Anna        Google      8000      
2           Liisa       Google      7500      
3           Kaaleppi    Amazon      5000      
4           Uolevi      Amazon      8000      
5           Maija       Google      9500      
6           Vihtori     Facebook    5000    
</code></pre></div></div>

<p>Seuraava kysely hakee kunkin yrityksen työntekijöiden määrän:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">yritys</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tyontekijat</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">yritys</span><span class="p">;</span>
</code></pre></div></div>

<p>Kyselyn tulos on seuraava:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>yritys      COUNT(*)  
----------  ----------
Amazon      2         
Facebook    1
Google      3    
</code></pre></div></div>

<p>Tämä tarkoittaa, että Amazonilla on 2 työntekijää, Facebookilla on 1 työntekijä ja Googlella on 3 työntekijää.</p>

<h4 id="miten-ryhmittely-toimii">Miten ryhmittely toimii?</h4>

<p>Äskeisessä kyselyssä ryhmittelyn ehtona on <code class="language-html highlighter-rouge">GROUP BY yritys</code>, joten rivit jaetaan ryhmiin sarakkeen <code class="language-html highlighter-rouge">yritys</code> mukaan. Tässä tapauksessa ryhmät ovat:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        yritys      palkka    
----------  ----------  ----------  ----------
3           Kaaleppi    Amazon      5000      
4           Uolevi      Amazon      8000      
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        yritys      palkka    
----------  ----------  ----------  ----------
6           Vihtori     Facebook    5000    
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        yritys      palkka    
----------  ----------  ----------  ----------
1           Anna        Google      8000      
2           Liisa       Google      7500      
5           Maija       Google      9500     
</code></pre></div></div>

<p>Tämän jälkeen jokaiselle ryhmälle lasketaan rivien määrä koostefunktion <code class="language-html highlighter-rouge">COUNT(*)</code> avulla.</p>

<p>Ryhmittely tuottaa tulostaulun, jonka rivien määrä on sama kuin ryhmien määrä. Jokaisella rivillä voi esiintyä ryhmittelyssä käytettyjä sarakkeita sekä koostefunktioita.</p>

<p>Huomaa, että SQLite sallii myös seuraavan kyselyn, jossa haetaan ryhmittelyn ulkopuolinen sarake:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">yritys</span><span class="p">,</span> <span class="n">nimi</span> <span class="k">FROM</span> <span class="n">Tyontekijat</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">yritys</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>yritys      nimi      
----------  ----------
Amazon      Uolevi    
Facebook    Vihtori
Google      Maija    
</code></pre></div></div>

<p>Koska sarake <code class="language-html highlighter-rouge">nimi</code> ei kuulu ryhmittelyyn, sillä voi olla useita arvoja ryhmässä ja tulostauluun tulee yksi niistä. Tällainen kysely ei kuitenkaan toimi kaikissa tietokannoissa.</p>

<h4 id="lisää-kyselyjä">Lisää kyselyjä</h4>

<p>Seuraava kysely hakee joka yrityksestä palkkojen summan:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">yritys</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">palkka</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tyontekijat</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">yritys</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>yritys      SUM(palkka)
----------  -----------
Amazon      13000      
Facebook    5000
Google      25000   
</code></pre></div></div>

<p>Seuraava kysely puolestaan hakee korkeimman palkan:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">yritys</span><span class="p">,</span> <span class="k">MAX</span><span class="p">(</span><span class="n">palkka</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tyontekijat</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">yritys</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>yritys      MAX(palkka)
----------  -----------
Amazon      8000   
Facebook    5000
Google      9500
</code></pre></div></div>

<h3 id="tulossarakkeen-nimentä">Tulossarakkeen nimentä</h3>

<p>Oletuksena tulostaulun sarake saa nimen suoraan kyselyn perusteella, mutta voimme halutessamme antaa myös oman nimen <code class="language-html highlighter-rouge">AS</code>-sanan avulla. Tämän ansiosta voimme esimerkiksi selventää,
mistä yhteenvetokyselyssä on kyse.</p>

<p>Esimerkiksi seuraavassa kyselyssä toisen sarakkeen nimeksi tulee <code class="language-html highlighter-rouge">korkein</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">yritys</span><span class="p">,</span> <span class="k">MAX</span><span class="p">(</span><span class="n">palkka</span><span class="p">)</span> <span class="k">AS</span> <span class="n">korkein</span> <span class="k">FROM</span> <span class="n">Tyontekijat</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">yritys</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>yritys      korkein
----------  ----------
Amazon      8000         
Facebook    5000
Google      9500       
</code></pre></div></div>

<p>Sana <code class="language-html highlighter-rouge">AS</code> ei ole pakollinen, eli voisimme kirjoittaa kyselyn myös näin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">yritys</span><span class="p">,</span> <span class="k">MAX</span><span class="p">(</span><span class="n">palkka</span><span class="p">)</span> <span class="n">korkein</span> <span class="k">FROM</span> <span class="n">Tyontekijat</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">yritys</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="rajaus-ryhmittelyn-jälkeen">Rajaus ryhmittelyn jälkeen</h3>

<p>Voimme lisätä kyselyyn myös <code class="language-html highlighter-rouge">HAVING</code>-osan, joka rajaa tuloksia ryhmittelyn jälkeen. Esimerkiksi seuraava kysely hakee yritykset, joissa on ainakin kaksi työntekijää:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">yritys</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tyontekijat</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">yritys</span> <span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>yritys      COUNT(*)  
----------  ----------
Amazon      2         
Google      3     
</code></pre></div></div>

<p>Voimme myös käyttää koostefunktiota vain <code class="language-html highlighter-rouge">HAVING</code>-osassa:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">yritys</span> <span class="k">FROM</span> <span class="n">Tyontekijat</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">yritys</span> <span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>yritys    
----------
Amazon    
Google    
</code></pre></div></div>

<h3 id="kyselyn-yleiskuva">Kyselyn yleiskuva</h3>

<p>SQL-kyselyn yleiskuva on seuraava:</p>

<p><code class="language-html highlighter-rouge">SELECT</code> – <code class="language-html highlighter-rouge">FROM</code> – <code class="language-html highlighter-rouge">WHERE</code> – <code class="language-html highlighter-rouge">GROUP BY</code> – <code class="language-html highlighter-rouge">HAVING</code> – <code class="language-html highlighter-rouge">ORDER BY</code></p>

<p>Kyselystä riippuu, mitkä näistä osista siinä esiintyvät. Tämä on kuitenkin aina järjestys,
jossa kyselyn osat sijaitsevat toisiinsa nähden.</p>

<p>Seuraavassa on esimerkki kyselystä, joka sisältää yhtä aikaa kaikki nämä osat.</p>

<h4 id="esimerkki-2">Esimerkki</h4>

<p>Tarkastellaan taulua <code class="language-html highlighter-rouge">Tehtavat</code>, jossa on projekteihin liittyviä tehtäviä. Jokaisella tehtävällä on tietty tärkeysaste. Tehtävä on <em>kriittinen</em>, jos sen tärkeysaste on ainakin 3.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          projekti_id  tarkeys   
----------  -----------  ----------
1           1            3         
2           1            4         
3           1            4         
4           2            1         
5           2            5         
6           3            2         
7           3            4         
8           3            5   
</code></pre></div></div>

<p>Seuraava kysely etsii projektit, joissa on vähintään kaksi kriittistä tehtävää, ja järjestää ne projektin id-numeron mukaan:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">projekti_id</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">FROM</span>
  <span class="n">Tehtavat</span>
<span class="k">WHERE</span>
  <span class="n">tarkeys</span> <span class="o">&gt;=</span> <span class="mi">3</span>
<span class="k">GROUP</span> <span class="k">BY</span>
  <span class="n">projekti_id</span>
<span class="k">HAVING</span>
  <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="k">ORDER</span> <span class="k">BY</span>
  <span class="n">projekti_id</span><span class="p">;</span>
</code></pre></div></div>

<p>Kyselyn tulos on tässä:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>projekti_id  COUNT(*)  
-----------  ----------
1            3         
3            2         
</code></pre></div></div>

<p>Tämä tarkoittaa, että projektissa 1 on 3 kriittistä tehtävää ja projektissa 3 on 2 kriittistä tehtävää.</p>

<h4 id="miten-kysely-toimii">Miten kysely toimii?</h4>

<p>Kyselyn lähtökohtana ovat kaikki taulussa <code class="language-html highlighter-rouge">Tehtavat</code> olevat rivit. Ehto <code class="language-html highlighter-rouge">WHERE tarkeys &gt;= 3</code> valitsee käsittelyyn seuraavat rivit:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          projekti_id  tarkeys   
----------  -----------  ----------
1           1            3         
2           1            4         
3           1            4         
5           2            5         
7           3            4         
8           3            5   
</code></pre></div></div>

<p>Kyselyssä on käytössä ryhmittely <code class="language-html highlighter-rouge">GROUP BY projekti_id</code>, joka jakaa rivit ryhmiin näin:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          projekti_id  tarkeys   
----------  -----------  ----------
1           1            3         
2           1            4         
3           1            4         
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          projekti_id  tarkeys   
----------  -----------  ----------
5           2            5         
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          projekti_id  tarkeys   
----------  -----------  ----------
7           3            4         
8           3            5   
</code></pre></div></div>

<p>Osa <code class="language-html highlighter-rouge">HAVING COUNT(*) &gt;= 2</code> valitsee ryhmät, joissa on ainakin kaksi riviä:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          projekti_id  tarkeys   
----------  -----------  ----------
1           1            3         
2           1            4         
3           1            4         
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          projekti_id  tarkeys   
----------  -----------  ----------
7           3            4         
8           3            5   
</code></pre></div></div>

<p>Tulostauluun valitaan joka ryhmästä sarake <code class="language-html highlighter-rouge">projekti_id</code> sekä funktion <code class="language-html highlighter-rouge">COUNT(*)</code> arvo, ja <code class="language-html highlighter-rouge">ORDER BY projekti_id</code> järjestää rivit projektin id-numeron mukaan:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>projekti_id  COUNT(*)  
-----------  ----------
1            3       
3            2         
</code></pre></div></div>

<h2 id="sqlite-tietokanta">SQLite-tietokanta</h2>

<p>SQLite on yksinkertainen avoimesti saatavilla oleva tietokantajärjestelmä, joka soveltuu hyvin SQL-kielen opetteluun. Voit kokeilla helposti SQL-kieleen liittyviä asioita SQLiten avulla,
ja käytämme sitä tämän kurssin harjoituksissa.</p>

<p>SQLite on mainio valinta SQL-kielen harjoitteluun, mutta siinä on tiettyjä rajoituksia, jotka voivat aiheuttaa ongelmia todellisissa sovelluksissa. Muita suosittuja avoimia tietokantajärjestelmiä ovat MySQL ja PostgreSQL. Niissä on suuri määrä ominaisuuksia, jotka puuttuvat SQLitestä, mutta toisaalta niiden asentaminen ja käyttäminen on vaikeampaa.</p>

<p>Eri tietokantajärjestelmien välillä siirtyminen on onneksi helppoa, koska kaikissa on samantapainen SQL-kieli. Tutustumme PostgreSQL-tietokannan käyttämiseen myöhemmin <em>Tietokantasovellus</em>-kurssilla.</p>

<h3 id="sqlite-tulkki">SQLite-tulkki</h3>

<p>SQLite-tulkki on ohjelma, jonka kautta voidaan käyttää SQLite-tietokantaa. Tulkki käynnistyy antamalla komentorivillä komento <code class="language-html highlighter-rouge">sqlite3</code>. Tämän jälkeen tulkkiin voi kirjoittaa joko suoritettavia SQL-komentoja tai pisteellä alkavia SQLite-tulkin omia komentoja.</p>

<p>Jos käyttämälläsi koneella ei ole vielä SQLite-tulkkia, voit asentaa sen tästä:</p>

<ul>
  <li><a href="https://www.sqlite.org/download.html">https://www.sqlite.org/download.html</a></li>
</ul>

<p>Valitse oman käyttöjärjestelmäsi mukainen paketti, jonka vieressä on otsikko <em>command-line tools</em> (eli komentorivityökalut). Tarvittava tiedosto on se, jonka nimi alkaa <code class="language-html highlighter-rouge">sqlite3</code>.</p>

<h3 id="esimerkki-3">Esimerkki</h3>

<p>SQLite-tulkissa tietokanta on oletuksena muistissa (<em>in-memory database</em>), jolloin se on aluksi tyhjä ja katoaa, kun tulkki suljetaan. Tämä on hyvä tapa testailla SQL-kielen ominaisuuksia. Keskustelu tulkin kanssa voi näyttää vaikkapa tältä:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">$ </span>sqlite3
SQLite version 3.11.0 2016-02-15 17:29:24
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
<span class="p">sqlite&gt; </span>CREATE TABLE Tuotteet (id INTEGER PRIMARY KEY, nimi TEXT, hinta INTEGER);
<span class="p">sqlite&gt; </span>.tables
Tuotteet
<span class="p">sqlite&gt; </span>INSERT INTO Tuotteet (nimi,hinta) VALUES ('retiisi',7);
<span class="p">sqlite&gt; </span>INSERT INTO Tuotteet (nimi,hinta) VALUES ('porkkana',5);
<span class="p">sqlite&gt; </span>INSERT INTO Tuotteet (nimi,hinta) VALUES ('nauris',4);
<span class="p">sqlite&gt; </span>INSERT INTO Tuotteet (nimi,hinta) VALUES ('lanttu',8);
<span class="p">sqlite&gt; </span>INSERT INTO Tuotteet (nimi,hinta) VALUES ('selleri',4);
<span class="p">sqlite&gt; </span>SELECT * FROM Tuotteet;
1|retiisi|7
2|porkkana|5
3|nauris|4
4|lanttu|8
5|selleri|4
<span class="p">sqlite&gt; </span>.mode column
<span class="p">sqlite&gt; </span>.headers on
<span class="p">sqlite&gt; </span>SELECT * FROM Tuotteet;
id          nimi        hinta     
----------  ----------  ----------
1           retiisi     7         
2           porkkana    5         
3           nauris      4         
4           lanttu      8         
5           selleri     4         
<span class="p">sqlite&gt; </span>.quit
</code></pre></div></div>

<p>Esimerkissä luomme aluksi taulun <code class="language-html highlighter-rouge">Tuotteet</code> ja tarkastamme sitten komennolla <code class="language-html highlighter-rouge">.tables</code>, mitä tauluja tietokannassa on. Ainoa taulu on <code class="language-html highlighter-rouge">Tuotteet</code>, mikä kuuluu asiaan.</p>

<p>Tämän jälkeen lisäämme tauluun rivejä ja haemme sitten kaikki rivit taulusta. SQLite-tulkin oletustapa näyttää tulosrivit pystyviivoin erotettuina ei ole kovin tyylikäs, minkä vuoksi parannamme tulostusta komennoilla <code class="language-html highlighter-rouge">.mode column</code> (jokaisella sarakkeella on kiinteä leveys) ja <code class="language-html highlighter-rouge">.headers on</code> (sarakkeiden nimet näytetään).</p>

<p>Lopuksi suoritamme komennon <code class="language-html highlighter-rouge">.quit</code>, joka sulkee SQLite-tulkin.</p>

<h3 id="tietokanta-tiedostossa">Tietokanta tiedostossa</h3>

<p>Käynnistyksen yhteydessä SQLite-tulkille voi antaa parametrina tiedoston, johon tietokanta tallennetaan. Tällöin tietokannan sisältö säilyy tallessa tulkin sulkemisen jälkeen.</p>

<p>Seuraavassa esimerkissä tietokanta tallennetaan tiedostoon <code class="language-html highlighter-rouge">testi.db</code>. Tämän ansiosta tietokannan sisältö on edelleen tallessa, kun tulkki käynnistetään uudestaan.</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">$ </span>sqlite3 testi.db
SQLite version 3.11.0 2016-02-15 17:29:24
Enter ".help" for usage hints.
<span class="p">sqlite&gt; </span>CREATE TABLE Tuotteet (id INTEGER PRIMARY KEY, nimi TEXT, hinta INTEGER);
<span class="p">sqlite&gt; </span>.tables
Tuotteet
<span class="p">sqlite&gt; </span>.quit
<span class="p">$ </span>sqlite3 testi.db
SQLite version 3.11.0 2016-02-15 17:29:24
Enter ".help" for usage hints.
<span class="p">sqlite&gt; </span>.tables
Tuotteet
<span class="p">sqlite&gt; </span>.quit
</code></pre></div></div>

<h3 id="komennot-tiedostosta">Komennot tiedostosta</h3>

<p>Voimme myös ohjata SQLite-tulkille tiedoston, jossa olevat komennot suoritetaan peräkkäin. Tämän avulla voimme automatisoida komentojen suorittamista. Esimerkiksi voimme laatia seuraavan tiedoston <code class="language-html highlighter-rouge">komennot.sql</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>CREATE TABLE Tuotteet (id INTEGER PRIMARY KEY, nimi TEXT, hinta INTEGER);
INSERT INTO Tuotteet (nimi,hinta) VALUES ('retiisi',7);
INSERT INTO Tuotteet (nimi,hinta) VALUES ('porkkana',5);
INSERT INTO Tuotteet (nimi,hinta) VALUES ('nauris',4);
INSERT INTO Tuotteet (nimi,hinta) VALUES ('lanttu',8);
INSERT INTO Tuotteet (nimi,hinta) VALUES ('selleri',4);
.mode column
.headers on
SELECT * FROM Tuotteet;
</code></pre></div></div>

<p>Tämän jälkeen voimme ohjata komennot tiedostosta tulkille näin:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">$ </span>sqlite3 &lt; komennot.sql
id          nimi        hinta     
----------  ----------  ----------
1           retiisi     7         
2           porkkana    5         
3           nauris      4         
4           lanttu      8         
5           selleri     4         
</code></pre></div></div>

<h1 id="3-monen-taulun-kyselyt">3. Monen taulun kyselyt</h1>

<h2 id="taulujen-viittaukset">Taulujen viittaukset</h2>

<p>Keskeinen idea tietokannoissa on, että taulun rivi voi viitata toisen taulun riviin. Tällöin voimme muodostaa kyselyn, joka kerää tietoa useista tauluista viittausten perusteella. Käytännössä viittauksena on yleensä toisessa taulussa olevan rivin id-numero.</p>

<h3 id="esimerkki-4">Esimerkki</h3>

<p>Tarkastellaan esimerkkinä tilannetta, jossa tietokannassa on tietoa kursseista ja niiden opettajista. Oletamme, että jokaisella kurssilla on yksi opettaja ja sama opettaja voi opettaa monta kurssia.</p>

<p>Tallennamme tauluun <code class="language-html highlighter-rouge">Opettajat</code> tietoa opettajista. Jokaisella opettajalla on id-numero, jolla voimme viitata siihen.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi      
----------  ----------
1           Kaila     
2           Luukkainen
3           Kivinen   
4           Laaksonen 
</code></pre></div></div>

<p>Taulussa <code class="language-html highlighter-rouge">Kurssit</code> on puolestaan tietoa kursseista ja jokaisen kurssin kohdalla viittaus kurssin opettajaan.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi              opettaja_id
----------  ----------------  -----------
1           Laskennan mallit  3          
2           Ohjelmoinnin per  1          
3           Ohjelmoinnin jat  1          
4           Tietokantojen pe  4          
5           Tietorakenteet j  3        
</code></pre></div></div>

<p>Voimme nyt hakea kurssit opettajineen seuraavalla kyselyllä, joka hakee tietoa samaan aikaan tauluista <code class="language-html highlighter-rouge">Kurssit</code> ja <code class="language-html highlighter-rouge">Opettajat</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Kurssit</span><span class="p">,</span> <span class="n">Opettajat</span>
<span class="k">WHERE</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">opettaja_id</span> <span class="o">=</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Koska kyselyssä on monta taulua, ilmoitamme sarakkeiden taulut. Esimerkiksi <code class="language-html highlighter-rouge">Kurssit.nimi</code> viittaa taulun <code class="language-html highlighter-rouge">Kurssit</code> sarakkeeseen <code class="language-html highlighter-rouge">nimi</code>.</p>

<p>Kysely antaa seuraavan tuloksen:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi              nimi      
----------------  ----------
Laskennan mallit  Kivinen   
Ohjelmoinnin per  Kaila     
Ohjelmoinnin jat  Kaila     
Tietokantojen pe  Laaksonen 
Tietorakenteet j  Kivinen 
</code></pre></div></div>

<h3 id="mitä-tässä-tapahtui">Mitä tässä tapahtui?</h3>

<p>Yllä olevassa kyselyssä uutena asiana on, että kysely koskee useaa taulua (<code class="language-html highlighter-rouge">FROM Kurssit, Opettajat</code>), mutta mitä tämä tarkoittaa oikeastaan?</p>

<p>Ideana on, että kun kyselyssä on monta taulua, kyselyn tulosrivien lähtökohtana ovat <em>kaikki</em> tavat valita rivien yhdistelmiä tauluista. Tämän jälkeen <code class="language-html highlighter-rouge">WHERE</code>-osan ehdoilla voi määrittää, mitkä yhdistelmät ovat kiinnostuksen kohteena.</p>

<p>Hyvä tapa saada ymmärrystä monen taulun kyselyn toiminnasta on tarkastella ensin kyselyä, joka hakee kaikki sarakkeet ja jossa ei ole <code class="language-html highlighter-rouge">WHERE</code>-osaa. Yllä olevassa esimerkkitilanteessa tällainen kysely on seuraava:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="o">*</span>
<span class="k">FROM</span>
  <span class="n">Kurssit</span><span class="p">,</span> <span class="n">Opettajat</span><span class="p">;</span>
</code></pre></div></div>

<p>Koska taulussa <code class="language-html highlighter-rouge">Kurssit</code> on 5 riviä ja taulussa <code class="language-html highlighter-rouge">Opettajat</code> on 4 riviä, kyselyn tulostaulussa on 5 * 4 = 20 riviä. Tulostaulu sisältää kaikki mahdolliset tavat valita ensin jokin rivi taulusta <code class="language-html highlighter-rouge">Kurssit</code> ja sitten jokin rivi taulusta <code class="language-html highlighter-rouge">Opettajat</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi              opettaja_id  id          nimi      
----------  ----------------  -----------  ----------  ----------
1           Laskennan mallit  3            1           Kaila     
1           Laskennan mallit  3            2           Luukkainen
1           Laskennan mallit  3            3           Kivinen   
1           Laskennan mallit  3            4           Laaksonen 
2           Ohjelmoinnin per  1            1           Kaila     
2           Ohjelmoinnin per  1            2           Luukkainen
2           Ohjelmoinnin per  1            3           Kivinen   
2           Ohjelmoinnin per  1            4           Laaksonen 
3           Ohjelmoinnin jat  1            1           Kaila     
3           Ohjelmoinnin jat  1            2           Luukkainen
3           Ohjelmoinnin jat  1            3           Kivinen   
3           Ohjelmoinnin jat  1            4           Laaksonen 
4           Tietokantojen pe  4            1           Kaila     
4           Tietokantojen pe  4            2           Luukkainen
4           Tietokantojen pe  4            3           Kivinen   
4           Tietokantojen pe  4            4           Laaksonen 
5           Tietorakenteet j  3            1           Kaila     
5           Tietorakenteet j  3            2           Luukkainen
5           Tietorakenteet j  3            3           Kivinen   
5           Tietorakenteet j  3            4           Laaksonen 
</code></pre></div></div>

<p>Suurin osa tulosriveistä ei ole kuitenkaan kiinnostavia, koska ne eivät liity toisiinsa mitenkään. Esimerkiksi ensimmäinen tulosrivi kertoo vain, että on olemassa kurssi Laskennan mallit ja toisaalta on olemassa opettaja Kaila. Tämän vuoksi rajaamme hakua niin, että opettajan id-numeron tulee olla sama kummankin taulun riveissä:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="o">*</span>
<span class="k">FROM</span>
  <span class="n">Kurssit</span><span class="p">,</span> <span class="n">Opettajat</span>
<span class="k">WHERE</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">opettaja_id</span> <span class="o">=</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Tämän seurauksena kysely alkaa antaa mielekkäitä tuloksia:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi              opettaja_id  id          nimi      
----------  ----------------  -----------  ----------  ----------
1           Laskennan mallit  3            3           Kivinen   
2           Ohjelmoinnin per  1            1           Kaila     
3           Ohjelmoinnin jat  1            1           Kaila     
4           Tietokantojen pe  4            4           Laaksonen 
5           Tietorakenteet j  3            3           Kivinen   
</code></pre></div></div>

<p>Tämän jälkeen voimme vielä parantaa kyselyä valitsemalla meitä kiinnostavat sarakkeet:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Kurssit</span><span class="p">,</span> <span class="n">Opettajat</span>
<span class="k">WHERE</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">opettaja_id</span> <span class="o">=</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Näin päädymme samaan tulokseen kuin aiemmin:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi              nimi      
----------------  ----------
Laskennan mallit  Kivinen   
Ohjelmoinnin per  Kaila     
Ohjelmoinnin jat  Kaila     
Tietokantojen pe  Laaksonen 
Tietorakenteet j  Kivinen 
</code></pre></div></div>

<h3 id="lisää-ehtoja-kyselyssä">Lisää ehtoja kyselyssä</h3>

<p>Monen taulun kyselyissä <code class="language-html highlighter-rouge">WHERE</code>-osa kytkee toisiinsa meitä kiinnostavat taulujen rivit, mutta lisäksi voimme laittaa <code class="language-html highlighter-rouge">WHERE</code>-osaan muita ehtoja samaan tapaan kuin ennenkin. Esimerkiksi voimme suorittaa seuraavan kyselyn:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Kurssit</span><span class="p">,</span> <span class="n">Opettajat</span>
<span class="k">WHERE</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">opettaja_id</span> <span class="o">=</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">id</span> <span class="k">AND</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">nimi</span> <span class="o">=</span> <span class="s1">'Kivinen'</span><span class="p">;</span>
</code></pre></div></div>

<p>Näin saamme haettua kurssit, joiden opettajana on Kivinen:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi              nimi      
----------------  ----------
Laskennan mallit  Kivinen   
Tietorakenteet j  Kivinen 
</code></pre></div></div>

<h3 id="taulujen-lyhyet-nimet">Taulujen lyhyet nimet</h3>

<p>Voimme tiivistää monen taulun kyselyä antamalla tauluille vaihtoehtoiset lyhyet nimet, joiden avulla voimme viitata niihin kyselyssä. Esimerkiksi kysely</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Kurssit</span><span class="p">,</span> <span class="n">Opettajat</span>
<span class="k">WHERE</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">opettaja_id</span> <span class="o">=</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>voidaan esittää lyhemmin näin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">K</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">O</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Kurssit</span> <span class="k">AS</span> <span class="n">K</span><span class="p">,</span> <span class="n">Opettajat</span> <span class="k">AS</span> <span class="n">O</span>
<span class="k">WHERE</span>
  <span class="n">K</span><span class="p">.</span><span class="n">opettaja_id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Sana <code class="language-html highlighter-rouge">AS</code> ei ole pakollinen, eli voimme lyhentää kyselyä lisää:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">K</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">O</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Kurssit</span> <span class="n">K</span><span class="p">,</span> <span class="n">Opettajat</span> <span class="n">O</span>
<span class="k">WHERE</span>
  <span class="n">K</span><span class="p">.</span><span class="n">opettaja_id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="saman-taulun-toistaminen">Saman taulun toistaminen</h3>

<p>Monen taulun kyselyssä voi esiintyä myös monta kertaa sama taulu, kunhan niille annetaan eri nimet. Esimerkiksi seuraava kysely hakee kaikki tavat valita kahden opettajan <em>pari</em>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">A</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">B</span><span class="p">.</span><span class="n">nimi</span> <span class="k">FROM</span> <span class="n">Opettajat</span> <span class="n">A</span><span class="p">,</span> <span class="n">Opettajat</span> <span class="n">B</span><span class="p">;</span>
</code></pre></div></div>

<p>Kyselyn tulos on seuraava:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi        nimi      
----------  ----------
Kaila       Kaila     
Kaila       Luukkainen
Kaila       Kivinen   
Kaila       Laaksonen 
Luukkainen  Kaila     
Luukkainen  Luukkainen
Luukkainen  Kivinen   
Luukkainen  Laaksonen 
Kivinen     Kaila     
Kivinen     Luukkainen
Kivinen     Kivinen   
Kivinen     Laaksonen 
Laaksonen   Kaila     
Laaksonen   Luukkainen
Laaksonen   Kivinen   
Laaksonen   Laaksonen 
</code></pre></div></div>

<h2 id="liitostaulut">Liitostaulut</h2>

<p>Taulujen välillä esiintyy yleensä kahdenlaisia suhteita:</p>

<ol>
  <li>
    <p><em>Yksi moneen -suhde</em>:
Taulun A rivi liittyy enintään yhteen taulun B riviin.
Taulun B rivi voi liittyä useaan taulun A riviin.</p>
  </li>
  <li>
    <p><em>Monta moneen -suhde</em>:
Taulun A rivi voi liittyä useaan taulun B riviin.
Taulun B rivi voi liittyä useaan taulun A riviin.</p>
  </li>
</ol>

<p>Tapauksessa 1 voimme lisätä tauluun A sarakkeen, joka viittaa tauluun B, kuten teimme edellisen osion esimerkissä. Tapauksessa 2 tilanne on kuitenkin hankalampi, koska yksittäinen viittaus kummankaan taulun rivissä ei riittäisi. Ratkaisuna on luoda kolmas <em>liitostaulu</em>, joka sisältää tiedot viittauksista.</p>

<h3 id="esimerkki-5">Esimerkki</h3>

<p>Tarkastellaan esimerkkinä tilannetta, jossa verkkokaupassa on tuotteita ja asiakkaita ja jokainen asiakas on valinnut tiettyjä tuotteita ostoskoriin. Tietyn asiakkaan korissa voi olla useita tuotteita, ja toisaalta tietty tuote voi olla usean asiakkaan korissa.</p>

<p>Rakennamme tietokannan niin, että siinä on kolme taulua: <code class="language-html highlighter-rouge">Tuotteet</code>, <code class="language-html highlighter-rouge">Asiakkaat</code> ja <code class="language-html highlighter-rouge">Ostokset</code>. Liitostaulu <code class="language-html highlighter-rouge">Ostokset</code> ilmaisee, mitä tuotteita on kunkin asiakkaan ostoskorissa. Sen jokainen rivi esittää yhden parin muotoa “asiakkaan <em>x</em> korissa on tuote <em>y</em>”.</p>

<p>Oletamme, että taulujen sisällöt ovat seuraavat:</p>

<table class="db-table">
<thead>
  <tr><th colspan="3" id="table-title">Tuotteet</th></tr>
  <tr><th width="30">id</th><th width="100">nimi</th><th width="70">hinta</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>retiisi</td><td>7</td></tr>
  <tr><td>2</td><td>porkkana</td><td>5</td></tr>
  <tr><td>3</td><td>nauris</td><td>4</td></tr>
  <tr><td>4</td><td>lanttu</td><td>8</td></tr>
  <tr><td>5</td><td>selleri</td><td>4</td></tr>
</tbody>
</table>

<table class="db-table">
<thead>
  <tr><th colspan="2" id="table-title">Asiakkaat</th></tr>
  <tr><th width="30">id</th><th width="100">nimi</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>Uolevi</td></tr>
  <tr><td>2</td><td>Maija</td></tr>
  <tr><td>3</td><td>Aapeli</td></tr>
</tbody>
</table>

<table class="db-table">
<thead>
  <tr><th colspan="2" id="table-title">Ostokset</th></tr>
  <tr><th width="100">asiakas_id</th><th width="100">tuote_id</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>2</td></tr>
  <tr><td>1</td><td>5</td></tr>
  <tr><td>2</td><td>1</td></tr>
  <tr><td>2</td><td>4</td></tr>
  <tr><td>2</td><td>5</td></tr>
</tbody>
</table>

<p>Nyt voimme hakea asiakkaat ja tuotteet seuraavasti:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">A</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">T</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Asiakkaat</span> <span class="n">A</span><span class="p">,</span> <span class="n">Tuotteet</span> <span class="n">T</span><span class="p">,</span> <span class="n">Ostokset</span> <span class="n">O</span>
<span class="k">WHERE</span>
  <span class="n">A</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">asiakas_id</span> <span class="k">AND</span> <span class="n">T</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">tuote_id</span><span class="p">;</span>
</code></pre></div></div>

<p>Kyselyn ideana on hakea tauluista <code class="language-html highlighter-rouge">Asiakkaat</code> ja <code class="language-html highlighter-rouge">Tuotteet</code> taulun <code class="language-html highlighter-rouge">Ostokset</code> rivejä vastaavat tiedot. Jotta saamme mielekkäitä tuloksia, kytkemme rivit yhteen kahden ehdon avulla. Kysely tuottaa seuraavan tulostaulun:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi        nimi      
----------  ----------
Uolevi      porkkana  
Uolevi      selleri   
Maija       retiisi   
Maija       lanttu    
Maija       selleri   
</code></pre></div></div>

<h3 id="miten-kysely-toimii-1">Miten kysely toimii?</h3>

<p>Voimme taas tutkia kyselyn toimintaa hakemalla kaikki sarakkeet ja poistamalla ehdot:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="o">*</span>
<span class="k">FROM</span>
  <span class="n">Asiakkaat</span> <span class="n">A</span><span class="p">,</span> <span class="n">Tuotteet</span> <span class="n">T</span><span class="p">,</span> <span class="n">Ostokset</span> <span class="n">O</span><span class="p">;</span>
</code></pre></div></div>

<p>Tämän kyselyn tulostaulussa on kaikki tavat valita jokin asiakas, tuote ja ostokset. Tulostaulussa on 5 * 3 * 5 = 75 riviä ja se alkaa näin:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        id          nimi        hinta       asiakas_id  tuote_id  
----------  ----------  ----------  ----------  ----------  ----------  ----------
1           Uolevi      1           retiisi     7           1           2         
1           Uolevi      1           retiisi     7           1           5         
1           Uolevi      1           retiisi     7           2           1         
1           Uolevi      1           retiisi     7           2           4         
1           Uolevi      1           retiisi     7           2           5         
1           Uolevi      2           porkkana    5           1           2         
1           Uolevi      2           porkkana    5           1           5         
1           Uolevi      2           porkkana    5           2           1         
1           Uolevi      2           porkkana    5           2           4         
1           Uolevi      2           porkkana    5           2           5         
1           Uolevi      3           nauris      4           1           2         
1           Uolevi      3           nauris      4           1           5         
1           Uolevi      3           nauris      4           2           1         
1           Uolevi      3           nauris      4           2           4         
1           Uolevi      3           nauris      4           2           5         
...
</code></pre></div></div>

<p>Sitten kun lisäämme kyselyyn ehdot, saamme rajattua kiinnostavat rivit:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="o">*</span>
<span class="k">FROM</span>
  <span class="n">Asiakkaat</span> <span class="n">A</span><span class="p">,</span> <span class="n">Tuotteet</span> <span class="n">T</span><span class="p">,</span> <span class="n">Ostokset</span> <span class="n">O</span>
<span class="k">WHERE</span>
  <span class="n">A</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">asiakas_id</span> <span class="k">AND</span> <span class="n">T</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">tuote_id</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        id          nimi        hinta       asiakas_id  tuote_id  
----------  ----------  ----------  ----------  ----------  ----------  ----------
1           Uolevi      2           porkkana    5           1           2         
1           Uolevi      5           selleri     4           1           5         
2           Maija       1           retiisi     7           2           1         
2           Maija       4           lanttu      8           2           4         
2           Maija       5           selleri     4           2           5     
</code></pre></div></div>

<p>Kun vielä määritämme halutut sarakkeet, tuloksena on lopullinen kysely:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">A</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">T</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Asiakkaat</span> <span class="n">A</span><span class="p">,</span> <span class="n">Tuotteet</span> <span class="n">T</span><span class="p">,</span> <span class="n">Ostokset</span> <span class="n">O</span>
<span class="k">WHERE</span>
  <span class="n">A</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">asiakas_id</span> <span class="k">AND</span> <span class="n">T</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">tuote_id</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi        nimi      
----------  ----------
Uolevi      porkkana  
Uolevi      selleri   
Maija       retiisi   
Maija       lanttu    
Maija       selleri   
</code></pre></div></div>

<h3 id="lisää-ehtoja-kyselyyn">Lisää ehtoja kyselyyn</h3>

<p>Voimme lisätä kyselyyn lisää ehtoja, jos haluamme saada selville muuta ostoskoreista. Esimerkiksi seuraava kysely hakee Maijan korissa olevat tuotteet:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">T</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Asiakkaat</span> <span class="n">A</span><span class="p">,</span> <span class="n">Tuotteet</span> <span class="n">T</span><span class="p">,</span> <span class="n">Ostokset</span> <span class="n">O</span>
<span class="k">WHERE</span>
  <span class="n">A</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">asiakas_id</span> <span class="k">AND</span> <span class="n">T</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">tuote_id</span> <span class="k">AND</span> <span class="n">A</span><span class="p">.</span><span class="n">nimi</span> <span class="o">=</span> <span class="s1">'Maija'</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi      
----------
retiisi   
lanttu    
selleri   
</code></pre></div></div>

<p>Seuraava kysely puolestaan kertoo, keiden korissa on selleri:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">A</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Asiakkaat</span> <span class="n">A</span><span class="p">,</span> <span class="n">Tuotteet</span> <span class="n">T</span><span class="p">,</span> <span class="n">Ostokset</span> <span class="n">O</span>
<span class="k">WHERE</span>
  <span class="n">A</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">asiakas_id</span> <span class="k">AND</span> <span class="n">T</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">tuote_id</span> <span class="k">AND</span> <span class="n">T</span><span class="p">.</span><span class="n">nimi</span> <span class="o">=</span> <span class="s1">'selleri'</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi      
----------
Uolevi    
Maija    
</code></pre></div></div>

<h3 id="yhteenveto-tauluista">Yhteenveto tauluista</h3>

<p>Voimme käyttää koostefunktioita ja ryhmittelyä myös usean taulun kyselyissä. Ne käsittelevät tulostaulua samalla periaatteella kuin yhden taulun kyselyissä.</p>

<h4 id="esimerkki-6">Esimerkki</h4>

<p>Tarkastellaan edelleen tietokantaa, jossa on tuotteita, asiakkaita ja ostoksia:</p>

<table class="db-table">
<thead>
  <tr><th colspan="3" id="table-title">Tuotteet</th></tr>
  <tr><th width="30">id</th><th width="100">nimi</th><th width="70">hinta</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>retiisi</td><td>7</td></tr>
  <tr><td>2</td><td>porkkana</td><td>5</td></tr>
  <tr><td>3</td><td>nauris</td><td>4</td></tr>
  <tr><td>4</td><td>lanttu</td><td>8</td></tr>
  <tr><td>5</td><td>selleri</td><td>4</td></tr>
</tbody>
</table>

<table class="db-table">
<thead>
  <tr><th colspan="2" id="table-title">Asiakkaat</th></tr>
  <tr><th width="30">id</th><th width="100">nimi</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>Uolevi</td></tr>
  <tr><td>2</td><td>Maija</td></tr>
  <tr><td>3</td><td>Aapeli</td></tr>
</tbody>
</table>

<table class="db-table">
<thead>
  <tr><th colspan="2" id="table-title">Ostokset</th></tr>
  <tr><th width="100">asiakas_id</th><th width="100">tuote_id</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>2</td></tr>
  <tr><td>1</td><td>5</td></tr>
  <tr><td>2</td><td>1</td></tr>
  <tr><td>2</td><td>4</td></tr>
  <tr><td>2</td><td>5</td></tr>
</tbody>
</table>

<p>Seuraava kysely luo yhteenvedon, joka näyttää jokaisesta asiakkaasta, montako tuotetta hänen ostoskorissaan on ja mikä on tuotteiden yhteishinta.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">A</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">T</span><span class="p">.</span><span class="n">id</span><span class="p">),</span> <span class="k">SUM</span><span class="p">(</span><span class="n">T</span><span class="p">.</span><span class="n">hinta</span><span class="p">)</span>
<span class="k">FROM</span>
  <span class="n">Asiakkaat</span> <span class="n">A</span><span class="p">,</span> <span class="n">Tuotteet</span> <span class="n">T</span><span class="p">,</span> <span class="n">Ostokset</span> <span class="n">O</span>
<span class="k">WHERE</span>
  <span class="n">A</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">asiakas_id</span> <span class="k">AND</span> <span class="n">T</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">tuote_id</span>
<span class="k">GROUP</span> <span class="k">BY</span>
  <span class="n">A</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Kyselyn tulos on seuraava:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi        COUNT(T.id)  SUM(T.hinta)
----------  -----------  ------------
Uolevi      2            9           
Maija       3            19          
</code></pre></div></div>

<p>Uolevin korissa on siis 2 tavaraa, joiden yhteishinta on 9, ja Maijan korissa on 3 tavaraa, joiden yhteishinta on 19.</p>

<h4 id="miten-kysely-toimii-2">Miten kysely toimii?</h4>

<p>Kyselyn perusta on tässä:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="o">*</span>
<span class="k">FROM</span>
  <span class="n">Asiakkaat</span> <span class="n">A</span><span class="p">,</span> <span class="n">Tuotteet</span> <span class="n">T</span><span class="p">,</span> <span class="n">Ostokset</span> <span class="n">O</span>
<span class="k">WHERE</span>
  <span class="n">A</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">asiakas_id</span> <span class="k">AND</span> <span class="n">T</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">tuote_id</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        id          nimi        hinta       asiakas_id  tuote_id  
----------  ----------  ----------  ----------  ----------  ----------  ----------
1           Uolevi      2           porkkana    5           1           2         
1           Uolevi      5           selleri     4           1           5         
2           Maija       1           retiisi     7           2           1         
2           Maija       4           lanttu      8           2           4         
2           Maija       5           selleri     4           2           5     
</code></pre></div></div>

<p>Kun kyselyyn lisätään ryhmittely <code class="language-html highlighter-rouge">GROUP BY A.id</code>, rivit jakautuvat kahteen ryhmään sarakkeen <code class="language-html highlighter-rouge">A.id</code> mukaan:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        id          nimi        hinta       asiakas_id  tuote_id  
----------  ----------  ----------  ----------  ----------  ----------  ----------
1           Uolevi      2           porkkana    5           1           2         
1           Uolevi      5           selleri     4           1           5         
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        id          nimi        hinta       asiakas_id  tuote_id  
----------  ----------  ----------  ----------  ----------  ----------  ----------
2           Maija       1           retiisi     7           2           1         
2           Maija       4           lanttu      8           2           4         
2           Maija       5           selleri     4           2           5     
</code></pre></div></div>

<p>Näille ryhmille lasketaan sitten tuotteiden määrä <code class="language-html highlighter-rouge">COUNT(T.id)</code> sekä ostosten yhteishinta <code class="language-html highlighter-rouge">SUM(T.hinta)</code>.</p>

<p>Huomaa, että kyselyssä ryhmittely tapahtuu sarakkeen <code class="language-html highlighter-rouge">A.id</code> mukaan, mutta kyselyssä haetaan sarake <code class="language-html highlighter-rouge">A.nimi</code>. Tämä on sinänsä järkevää, koska sarake <code class="language-html highlighter-rouge">A.id</code> määrää sarakkeen <code class="language-html highlighter-rouge">A.nimi</code>, ja kysely toimii mainiosti SQLitessä. Muissa tietokannoissa vaatimuksena voi kuitenkin olla, että sellaisenaan haettavan sarakkeen tulee aina esiintyä myös ryhmittelyssä. Tällöin ryhmittelyn tulisi olla <code class="language-html highlighter-rouge">GROUP BY A.id, A.nimi</code>.</p>

<h4 id="puuttuvan-rivin-ongelma">Puuttuvan rivin ongelma</h4>

<p>Kysely toimii sinänsä hyvin, mutta jotain puuttuu:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi        COUNT(T.id)  SUM(T.hinta)
----------  -----------  ------------
Uolevi      2            9           
Maija       3            19          
</code></pre></div></div>

<p>Kyselyn puutteena on vielä, että tuloksissa ei ole lainkaan kolmatta tietokannassa olevaa asiakasta eli Aapelia. Koska Aapelin korissa ei ole mitään, Aapelin rivi ei yhdisty minkään muun rivin kanssa eikä pääse osaksi tulostaulua.</p>

<p>Olemme törmänneet ongelmaan, mutta onneksi löydämme siihen ratkaisun pian.</p>

<h2 id="join-syntaksi">JOIN-syntaksi</h2>

<p>Tähän mennessä olemme hakeneet tietoa tauluista listaamalla taulut kyselyn <code class="language-html highlighter-rouge">FROM</code>-osassa, mikä toimii yleensä hyvin. Kuitenkin joskus on tarpeen vaihtoehtoinen <code class="language-html highlighter-rouge">JOIN</code>-syntaksi. Siitä on hyötyä silloin, kun kyselyn tuloksesta näyttää “puuttuvan” tietoa.</p>

<h3 id="kyselytavat">Kyselytavat</h3>

<p>Seuraavassa on kaksi tapaa toteuttaa sama kysely, ensin käyttäen ennestään tuttua tapaa ja sitten käyttäen <code class="language-html highlighter-rouge">JOIN</code>-syntaksia.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Kurssit</span><span class="p">,</span> <span class="n">Opettajat</span>
<span class="k">WHERE</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">opettaja_id</span> <span class="o">=</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Kurssit</span> <span class="k">JOIN</span> <span class="n">Opettajat</span> <span class="k">ON</span> <span class="n">Kurssit</span><span class="p">.</span><span class="n">opettaja_id</span> <span class="o">=</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-html highlighter-rouge">JOIN</code>-syntaksissa taulujen nimien välissä esiintyy sana <code class="language-html highlighter-rouge">JOIN</code> ja lisäksi taulujen rivit toisiinsa kytkevä ehto annetaan erillisessä <code class="language-html highlighter-rouge">ON</code>-osassa.</p>

<p>Tässä tapauksessa <code class="language-html highlighter-rouge">JOIN</code>-syntaksi on vain vaihtoehtoinen tapa toteuttaa kysely eikä se tuo mitään uutta. Kuitenkin näemme seuraavaksi, miten voimme laajentaa syntaksia niin, että se antaa meille uusia mahdollisuuksia kyselyissä.</p>

<h3 id="esimerkki-7">Esimerkki</h3>

<p>Tarkastellaan esimerkkinä tilannetta, jossa tietokannassa on tutut taulut <code class="language-html highlighter-rouge">Kurssit</code> ja <code class="language-html highlighter-rouge">Opettajat</code>, mutta taulussa <code class="language-html highlighter-rouge">Kurssit</code> yhdeltä kurssilta puuttuu opettaja:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi              opettaja_id
----------  ----------------  -----------
1           Laskennan mallit  3          
2           Ohjelmoinnin per  1          
3           Ohjelmoinnin jat  1          
4           Tietokantojen pe             
5           Tietorakenteet j  3          
</code></pre></div></div>

<p>Rivin 4 sarakkeessa <code class="language-html highlighter-rouge">opettaja_id</code> on arvo <code class="language-html highlighter-rouge">NULL</code>, joten jos suoritamme jommankumman äskeisen kyselyn, ongelmaksi tulee, että rivi 4 ei täsmää mihinkään taulun <code class="language-html highlighter-rouge">Opettajat</code> riviin. Tämän seurauksena tulostauluun ei tule riviä kurssista Tietokantojen perusteet:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi              nimi      
----------------  ----------
Laskennan mallit  Kivinen   
Ohjelmoinnin per  Kaila     
Ohjelmoinnin jat  Kaila     
Tietorakenteet j  Kivinen 
</code></pre></div></div>

<p>Ratkaisu ongelmaan on käyttää <code class="language-html highlighter-rouge">LEFT JOIN</code> -syntaksia, joka tarkoittaa, että mikäli jokin vasemman taulun rivi ei yhdisty mihinkään oikean taulun riviin, kyseinen vasemman taulun rivi pääsee silti mukaan yhdeksi riviksi tulostauluun. Kyseisellä rivillä jokaisen oikeaan tauluun perustuvan sarakkeen arvona on <code class="language-html highlighter-rouge">NULL</code>.</p>

<p>Tässä tapauksessa voimme toteuttaa kyselyn näin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Kurssit</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">Opettajat</span> <span class="k">ON</span> <span class="n">Kurssit</span><span class="p">.</span><span class="n">opettaja_id</span> <span class="o">=</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Nyt tulostauluun ilmestyy myös kurssi Tietokantojen perusteet ilman opettajaa:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi              nimi      
----------------  ----------
Laskennan mallit  Kivinen   
Ohjelmoinnin per  Kaila     
Ohjelmoinnin jat  Kaila     
Tietokantojen pe            
Tietorakenteet j  Kivinen
</code></pre></div></div>

<h3 id="miten-kysely-toimii-3">Miten kysely toimii?</h3>

<p>Jälleen hyvä tapa saada selkoa kyselystä on yksinkertaistaa sitä:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="o">*</span>
<span class="k">FROM</span>
  <span class="n">Kurssit</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">Opettajat</span> <span class="k">ON</span> <span class="n">Kurssit</span><span class="p">.</span><span class="n">opettaja_id</span> <span class="o">=</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi              opettaja_id  id          nimi      
----------  ----------------  -----------  ----------  ----------
1           Laskennan mallit  3            3           Kivinen   
2           Ohjelmoinnin per  1            1           Kaila     
3           Ohjelmoinnin jat  1            1           Kaila     
4           Tietokantojen pe                                     
5           Tietorakenteet j  3            3           Kivinen  
</code></pre></div></div>

<p>Tästä näkee, että koska vasemman taulun rivi 4 ei täsmää mihinkään oikean taulun riviin, niin kyseisestä rivistä tulee tulostauluun yksi rivi, jossa jokainen sarake oikean taulun osuudessa on <code class="language-html highlighter-rouge">NULL</code>.</p>

<h3 id="join-kyselyperhe">JOIN-kyselyperhe</h3>

<p>Itse asiassa <code class="language-html highlighter-rouge">JOIN</code>-kyselystä on olemassa peräti neljä eri muunnelmaa:</p>

<ul>
  <li><code class="language-html highlighter-rouge">JOIN</code>: toimii kuten tavallinen kahden taulun kysely</li>
  <li><code class="language-html highlighter-rouge">LEFT JOIN</code>: jos vasemman taulun rivi ei yhdisty mihinkään oikean taulun riviin,
se valitaan kuitenkin mukaan erikseen</li>
  <li><code class="language-html highlighter-rouge">RIGHT JOIN</code>: jos oikean taulun rivi ei yhdisty mihinkään vasemman taulun riviin,
se valitaan kuitenkin mukaan erikseen</li>
  <li><code class="language-html highlighter-rouge">FULL JOIN</code>: sekä vasemmasta että oikeasta taulusta valitaan erikseen mukaan
rivit, jotka eivät yhdisty toisen taulun riviin</li>
</ul>

<p>SQLiten rajoituksena on kuitenkin, että vain kaksi ensimmäistä kyselytapaa ovat mahdollisia. Onneksi <code class="language-html highlighter-rouge">LEFT JOIN</code> on yleensä se, mitä haluamme.</p>

<h3 id="on-vs-where">ON vs. WHERE</h3>

<p>Sana <code class="language-html highlighter-rouge">ON</code> on oleellinen <code class="language-html highlighter-rouge">LEFT JOIN</code> -kyselyssä, koska se asettaa ehdon niin, että mukaan otetaan myös vasemman taulun ylimääräiset rivit:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Kurssit</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">Opettajat</span> <span class="k">ON</span> <span class="n">Kurssit</span><span class="p">.</span><span class="n">opettaja_id</span> <span class="o">=</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi              nimi      
----------------  ----------
Laskennan mallit  Kivinen   
Ohjelmoinnin per  Kaila     
Ohjelmoinnin jat  Kaila     
Tietokantojen pe            
Tietorakenteet j  Kivinen
</code></pre></div></div>

<p>Jos käytämme sen sijasta sanaa <code class="language-html highlighter-rouge">WHERE</code>, ylimääräiset rivit jäävät pois:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Kurssit</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">Opettajat</span>
<span class="k">WHERE</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">opettaja_id</span> <span class="o">=</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi              nimi      
----------------  ----------
Laskennan mallit  Kivinen   
Ohjelmoinnin per  Kaila     
Ohjelmoinnin jat  Kaila     
Tietorakenteet j  Kivinen
</code></pre></div></div>

<p>Sinänsä kyselyssä voi esiintyä sekä <code class="language-html highlighter-rouge">ON</code> että <code class="language-html highlighter-rouge">WHERE</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Kurssit</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">Opettajat</span> <span class="k">ON</span> <span class="n">Kurssit</span><span class="p">.</span><span class="n">opettaja_id</span> <span class="o">=</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">nimi</span> <span class="o">&lt;&gt;</span> <span class="s1">'Ohjelmoinnin perusteet'</span><span class="p">;</span>
</code></pre></div></div>

<p>Tällöin <code class="language-html highlighter-rouge">ON</code>-osa hoitaa taulujen yhdistämisen ja <code class="language-html highlighter-rouge">WHERE</code>-osa rajaa tuloksia lisää:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi              nimi      
----------------  ----------
Laskennan mallit  Kivinen   
Ohjelmoinnin jat  Kaila     
Tietokantojen pe            
Tietorakenteet j  Kivinen   
</code></pre></div></div>

<p>Jos molemmat ehdot ovatkin <code class="language-html highlighter-rouge">ON</code>-osassa, kyselyn tulos muuttuu taas:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">Kurssit</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Kurssit</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">Opettajat</span> <span class="k">ON</span> <span class="n">Kurssit</span><span class="p">.</span><span class="n">opettaja_id</span> <span class="o">=</span> <span class="n">Opettajat</span><span class="p">.</span><span class="n">id</span> <span class="k">AND</span> 
                                 <span class="n">Kurssit</span><span class="p">.</span><span class="n">nimi</span> <span class="o">&lt;&gt;</span> <span class="s1">'Ohjelmoinnin perusteet'</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi              nimi      
----------------  ----------
Laskennan mallit  Kivinen   
Ohjelmoinnin per            
Ohjelmoinnin jat  Kaila     
Tietokantojen pe            
Tietorakenteet j  Kivinen   
</code></pre></div></div>

<h3 id="yhteenveto-toimivaksi">Yhteenveto toimivaksi</h3>

<p>Nyt voimme pureutua aiempaan ongelmaan, jossa yhteenvetokyselystä puuttui tietoa. Tietokannassamme on edelleen seuraavat taulut:</p>

<table class="db-table">
<thead>
  <tr><th colspan="3" id="table-title">Tuotteet</th></tr>
  <tr><th width="30">id</th><th width="100">nimi</th><th width="70">hinta</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>retiisi</td><td>7</td></tr>
  <tr><td>2</td><td>porkkana</td><td>5</td></tr>
  <tr><td>3</td><td>nauris</td><td>4</td></tr>
  <tr><td>4</td><td>lanttu</td><td>8</td></tr>
  <tr><td>5</td><td>selleri</td><td>4</td></tr>
</tbody>
</table>

<table class="db-table">
<thead>
  <tr><th colspan="2" id="table-title">Asiakkaat</th></tr>
  <tr><th width="30">id</th><th width="100">nimi</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>Uolevi</td></tr>
  <tr><td>2</td><td>Maija</td></tr>
  <tr><td>3</td><td>Aapeli</td></tr>
</tbody>
</table>

<table class="db-table">
<thead>
  <tr><th colspan="2" id="table-title">Ostokset</th></tr>
  <tr><th width="100">asiakas_id</th><th width="100">tuote_id</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>2</td></tr>
  <tr><td>1</td><td>5</td></tr>
  <tr><td>2</td><td>1</td></tr>
  <tr><td>2</td><td>4</td></tr>
  <tr><td>2</td><td>5</td></tr>
</tbody>
</table>

<p>Muodostimme yhteenvedon ostoskoreista seuraavalla kyselyllä:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">A</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">T</span><span class="p">.</span><span class="n">id</span><span class="p">),</span> <span class="k">SUM</span><span class="p">(</span><span class="n">T</span><span class="p">.</span><span class="n">hinta</span><span class="p">)</span>
<span class="k">FROM</span>
  <span class="n">Asiakkaat</span> <span class="n">A</span><span class="p">,</span> <span class="n">Tuotteet</span> <span class="n">T</span><span class="p">,</span> <span class="n">Ostokset</span> <span class="n">O</span>
<span class="k">WHERE</span>
  <span class="n">A</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">asiakas_id</span> <span class="k">AND</span> <span class="n">T</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">tuote_id</span>
<span class="k">GROUP</span> <span class="k">BY</span>
  <span class="n">A</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Kuitenkin ongelmaksi tuli, että Aapeli puuttuu yhteenvedosta:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi        COUNT(T.id)  SUM(T.hinta)
----------  -----------  ------------
Uolevi      2            9
Maija       3            19
</code></pre></div></div>

<h4 id="ratkaisu">Ratkaisu</h4>

<p>Ongelman syynä on, että Aapelin ostoskori on <em>tyhjä</em> eli kun kysely valitsee yhdistelmiä taulujen riveistä, ei ole mitään sellaista riviä, jolla esiintyisi Aapeli. Ratkaisu ongelmaan on käyttää <code class="language-html highlighter-rouge">LEFT JOIN</code> -syntaksia näin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">A</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">T</span><span class="p">.</span><span class="n">id</span><span class="p">),</span> <span class="k">SUM</span><span class="p">(</span><span class="n">T</span><span class="p">.</span><span class="n">hinta</span><span class="p">)</span>
<span class="k">FROM</span>
  <span class="n">Asiakkaat</span> <span class="n">A</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">Ostokset</span> <span class="n">O</span> <span class="k">ON</span> <span class="n">A</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">asiakas_id</span>
              <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">Tuotteet</span> <span class="n">T</span> <span class="k">ON</span> <span class="n">T</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">tuote_id</span>
<span class="k">GROUP</span> <span class="k">BY</span>
  <span class="n">A</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Nyt myös Aapeli ilmestyy mukaan yhteenvetoon:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi        COUNT(T.id)  SUM(T.hinta)
----------  -----------  ------------
Uolevi      2            9           
Maija       3            19          
Aapeli      0                     
</code></pre></div></div>

<p>Koska Aapelin ostoskorissa ei ole tuotteita, hintojen summaksi tulee <code class="language-html highlighter-rouge">NULL</code>. Voimme vielä parantaa kyselyä <code class="language-html highlighter-rouge">IFNULL</code>-funktion avulla:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">A</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">T</span><span class="p">.</span><span class="n">id</span><span class="p">),</span> <span class="n">IFNULL</span><span class="p">(</span><span class="k">SUM</span><span class="p">(</span><span class="n">T</span><span class="p">.</span><span class="n">hinta</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
<span class="k">FROM</span>
  <span class="n">Asiakkaat</span> <span class="n">A</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">Ostokset</span> <span class="n">O</span> <span class="k">ON</span> <span class="n">A</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">asiakas_id</span>
              <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">Tuotteet</span> <span class="n">T</span> <span class="k">ON</span> <span class="n">T</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">tuote_id</span>
<span class="k">GROUP</span> <span class="k">BY</span>
  <span class="n">A</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Tämän seurauksena mahdollinen <code class="language-html highlighter-rouge">NULL</code> muuttuu arvoksi 0:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi        COUNT(T.id)  IFNULL(SUM(T.hinta),0)
----------  -----------  ----------------------
Uolevi      2            9           
Maija       3            19          
Aapeli      0            0
</code></pre></div></div>

<p>Palaamme <code class="language-html highlighter-rouge">NULL</code>-arvojen käsittelyyn tarkemmin myöhemmin.</p>

<h4 id="miten-kysely-toimii-4">Miten kysely toimii?</h4>

<p>Kun kyselyssä on useita <code class="language-html highlighter-rouge">LEFT JOIN</code> -osia, tulkintana on, että ne yhdistävät tauluja vasemmalta oikealle. Yllä olevassa kyselyssä voimme ajatella, että ensimmäinen vaihe yhdistää taulut <code class="language-html highlighter-rouge">Asiakkaat</code> ja <code class="language-html highlighter-rouge">Ostokset</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="o">*</span>
<span class="k">FROM</span>
  <span class="n">Asiakkaat</span> <span class="n">A</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">Ostokset</span> <span class="n">O</span> <span class="k">ON</span> <span class="n">A</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">asiakas_id</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        asiakas_id  tuote_id  
----------  ----------  ----------  ----------
1           Uolevi      1           2         
1           Uolevi      1           5         
2           Maija       2           1         
2           Maija       2           4         
2           Maija       2           5         
3           Aapeli    
</code></pre></div></div>

<p>Toinen vaihe puolestaan yhdistää yllä olevan tulostaulun ja taulun <code class="language-html highlighter-rouge">Tuotteet</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="o">*</span>
<span class="k">FROM</span>
  <span class="n">Asiakkaat</span> <span class="n">A</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">Ostokset</span> <span class="n">O</span> <span class="k">ON</span> <span class="n">A</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">asiakas_id</span>
              <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">Tuotteet</span> <span class="n">T</span> <span class="k">ON</span> <span class="n">T</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">tuote_id</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        asiakas_id  tuote_id    id          nimi        hinta     
----------  ----------  ----------  ----------  ----------  ----------  ----------
1           Uolevi      1           2           2           porkkana    5         
1           Uolevi      1           5           5           selleri     4         
2           Maija       2           1           1           retiisi     7         
2           Maija       2           4           4           lanttu      8         
2           Maija       2           5           5           selleri     4         
3           Aapeli      
</code></pre></div></div>

<p>Molemmissa vaiheissa Aapeli pääsee osaksi tulostaulua,
koska kyseinen rivi ei täsmää minkään oikean taulun rivin kanssa.</p>

<h1 id="4-lisää-sql-kielestä">4. Lisää SQL-kielestä</h1>

<h2 id="tyypit-ja-lausekkeet">Tyypit ja lausekkeet</h2>

<p>SQL-kielessä esiintyy tyyppejä ja lausekkeita samaan tapaan kuin ohjelmoinnissa. Olemme jo nähneet monia esimerkkejä SQL-komennoista, mutta nyt on hyvä hetki tutustua syvällisemmin kielen rakenteeseen.</p>

<p>Jokainen tietokantajärjestelmä toteuttaa tyypit ja lausekkeet vähän omalla tavallaan ja tietokantojen toiminnassa on paljon pieniä eroja. Niinpä aiheeseen liittyvät yksityiskohdat kannattaa tarkastaa käytetyn tietokannan dokumentaatiosta.</p>

<h3 id="tyypit">Tyypit</h3>

<p>Taulun määrittelyssä jokaiselle sarakkeelle annetaan tyyppi:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Elokuvat</span><span class="p">(</span><span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="n">nimi</span> <span class="nb">TEXT</span><span class="p">,</span> <span class="n">vuosi</span> <span class="nb">INTEGER</span><span class="p">);</span>
</code></pre></div></div>

<p>Tässä sarakkeen <code class="language-html highlighter-rouge">nimi</code> tyyppi on <code class="language-html highlighter-rouge">TEXT</code> (merkkijono) ja sarakkeen <code class="language-html highlighter-rouge">vuosi</code> tyyppi on <code class="language-html highlighter-rouge">INTEGER</code> (kokonaisluku). Nämä ovat yleisimmät tyypit, jotka ovat saatavilla näillä nimillä monissa tietokannoissa. Esimerkkejä muista yleisistä tyypeistä ovat <code class="language-html highlighter-rouge">TIMESTAMP</code> (ajanhetki), <code class="language-html highlighter-rouge">REAL</code> (liukuluku) ja <code class="language-html highlighter-rouge">BLOB</code> (raakadata).</p>

<h4 id="text-vs-varchar">TEXT vs. VARCHAR</h4>

<p>Perinteikäs tapa tallentaa merkkijono SQL:ssä on käyttää tyyppiä <code class="language-html highlighter-rouge">VARCHAR</code>, jossa annetaan suluissa merkkijonon maksimipituus. Esimerkiksi tyyppi <code class="language-html highlighter-rouge">VARCHAR(10)</code> tarkoittaa, että merkkijonossa voi olla enintään 10 merkkiä.</p>

<p>Tämä on muistuma vanhan ajan ohjelmoinnista, jossa merkkijono saatettiin esittää kiinteän pituisena merkkitaulukkona. Tyyppi <code class="language-html highlighter-rouge">TEXT</code> on kuitenkin mukavampi, koska siinä ei tarvitse keksiä maksimipituutta.</p>

<h4 id="sqliten-tyypit">SQLiten tyypit</h4>

<p>Erikoinen piirre SQLiten toteutuksessa on, että taulun määrittelyssä esiintyvä tyyppi on vain ohje, mitä tyyppiä sarakkeessa tulisi olla. Voimme kuitenkin olla välittämättä ohjeesta ja vaikkapa tallentaa kokonaisluvun kohdalle merkkijonon:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Elokuvat</span> <span class="p">(</span><span class="n">nimi</span><span class="p">,</span><span class="n">vuosi</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Lumikki'</span><span class="p">,</span><span class="s1">'abc'</span><span class="p">);</span>
</code></pre></div></div>

<p>Lisäksi tyypin nimenä voi olla <em>mikä tahansa</em> merkkijono, vaikka SQLitessä ei olisi sellaista tyyppiä. Tämän avulla voimme esimerkiksi määritellä sarakkeen, johon on tarkoitus tallentaa ajanhetki:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Tapahtumat</span><span class="p">(</span><span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="n">paiva</span> <span class="nb">TIMESTAMP</span><span class="p">,</span> <span class="n">viesti</span> <span class="nb">TEXT</span><span class="p">);</span>
</code></pre></div></div>

<p>SQLitessä ei ole tyyppiä <code class="language-html highlighter-rouge">TIMESTAMP</code>, vaan ajanhetkiä käsitellään merkkijonoina, mutta tässä kuitenkin sarakkeen tyyppi ilmaisee, mitä siihen on tarkoitus tallentaa.</p>

<h3 id="lausekkeet">Lausekkeet</h3>

<p>Lauseke on SQL-komennon osa, jolla on tietty arvo.
Esimerkiksi kyselyssä</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">hinta</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">WHERE</span> <span class="n">nimi</span><span class="o">=</span><span class="s1">'retiisi'</span><span class="p">;</span>
</code></pre></div></div>

<p>on neljä lauseketta: <code class="language-html highlighter-rouge">hinta</code>, <code class="language-html highlighter-rouge">nimi</code>, <code class="language-html highlighter-rouge">'retiisi'</code> ja <code class="language-html highlighter-rouge">nimi='retiisi'</code>. Lausekkeet <code class="language-html highlighter-rouge">hinta</code> ja <code class="language-html highlighter-rouge">nimi</code> saavat arvonsa rivin sarakkeesta, lauseke <code class="language-html highlighter-rouge">'retiisi'</code> on merkkijonovakio ja lauseke <code class="language-html highlighter-rouge">nimi='retiisi'</code> on totuusarvoinen.</p>

<p>Voimme rakentaa monimutkaisempia lausekkeita samaan tapaan kuin ohjelmoinnissa. Esimerkiksi kysely</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">hinta</span><span class="o">*</span><span class="mi">5</span> <span class="k">FROM</span> <span class="n">Tuotteet</span><span class="p">;</span>
</code></pre></div></div>

<p>antaa jokaisen tuotteen hinnan viisinkertaisena ja kysely</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">nimi</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">WHERE</span> <span class="n">hinta</span><span class="o">%</span><span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>hakee tuotteet, joiden hinta on parillinen.</p>

<p>Hyvä tapa testata SQL:n lausekkeiden toimintaa on keskustella tietokannan kanssa tekemällä kyselyitä, jotka eivät hae tietoa mistään taulusta vaan laskevat vain tietyn lausekkeen arvon. Keskustelu voi näyttää vaikkapa seuraavalta:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>SELECT 2*(1+3);
8
<span class="p">sqlite&gt; </span>SELECT 'tes' || 'ti';
testi
<span class="p">sqlite&gt; </span>SELECT 3 &lt; 5;
1
</code></pre></div></div>

<p>Ensimmäinen kysely laskee lausekkeen <code class="language-html highlighter-rouge">2*(1+3)</code> arvon. Toinen kysely yhdistää <code class="language-html highlighter-rouge">||</code>-operaattorilla
merkkijonot <code class="language-html highlighter-rouge">'tes'</code> ja <code class="language-html highlighter-rouge">'ti'</code> merkkijonoksi <code class="language-html highlighter-rouge">'testi'</code>. Kolmas kysely puolestaan määrittää ehtolausekkeen <code class="language-html highlighter-rouge">3 <span class="nt">&lt;</span> <span class="nt">5</span></code> arvon. Tästä näkee, että SQLitessä kokonaisluku ilmaisee totuusarvon: 1 on tosi ja 0 on epätosi.</p>

<p>Monet SQL:n lausekkeisiin liittyvät asiat ovat tuttuja ohjelmoinnista:</p>

<ul>
  <li>laskutoimitukset: <code class="language-html highlighter-rouge">+</code>, <code class="language-html highlighter-rouge">-</code>, <code class="language-html highlighter-rouge">*</code>, <code class="language-html highlighter-rouge">/</code>, <code class="language-html highlighter-rouge">%</code></li>
  <li>vertaileminen: <code class="language-html highlighter-rouge">=</code>, <code class="language-html highlighter-rouge"><span class="nt">&lt;&gt;</span></code>, <code class="language-html highlighter-rouge"><span class="nt">&lt;</span></code>, <code class="language-html highlighter-rouge"><span class="nt">&lt;</span><span class="err">=</span></code>, <code class="language-html highlighter-rouge">&gt;</code>, <code class="language-html highlighter-rouge">&gt;=</code></li>
  <li>ehtojen yhdistys: <code class="language-html highlighter-rouge">AND</code>, <code class="language-html highlighter-rouge">OR</code>, <code class="language-html highlighter-rouge">NOT</code></li>
</ul>

<p>Näiden lisäksi SQL:ssä on kuitenkin myös erikoisempia ominaisuuksia, joiden tuntemisesta on välillä hyötyä. Seuraavassa on joitakin niistä:</p>

<h4 id="between">BETWEEN</h4>

<p>Lauseke <code class="language-html highlighter-rouge">x BETWEEN a AND b</code> on tosi, jos <code class="language-html highlighter-rouge">x</code> on vähintään <code class="language-html highlighter-rouge">a</code> ja enintään <code class="language-html highlighter-rouge">b</code>. Esimerkiksi kysely</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">WHERE</span> <span class="n">hinta</span> <span class="k">BETWEEN</span> <span class="mi">4</span> <span class="k">AND</span> <span class="mi">6</span><span class="p">;</span>
</code></pre></div></div>

<p>hakee tuotteet, joiden hinta on vähintään 4 ja korkeintaan 6. Voimme toki kirjoittaa samalla tavalla toimivan kyselyn myös näin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">WHERE</span> <span class="n">hinta</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="k">AND</span> <span class="n">hinta</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="case">CASE</h4>

<p>Rakenne <code class="language-html highlighter-rouge">CASE</code> mahdollistaa ehtolausekkeen tekemisen. Siinä voi olla yksi tai useampi <code class="language-html highlighter-rouge">WHEN</code>-osa sekä mahdollinen <code class="language-html highlighter-rouge">ELSE</code>-osa. Esimerkiksi kysely</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">nimi</span><span class="p">,</span> <span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">hinta</span><span class="o">&gt;</span><span class="mi">5</span> <span class="k">THEN</span> <span class="s1">'kallis'</span> <span class="k">ELSE</span> <span class="s1">'halpa'</span> <span class="k">END</span> <span class="k">FROM</span> <span class="n">Tuotteet</span><span class="p">;</span>
</code></pre></div></div>

<p>hakee kunkin tuotteen nimen sekä tiedon siitä, onko tuote kallis vai halpa. Tässä tuote on kallis, jos sen hinta on yli 5, ja muuten halpa.</p>

<h4 id="in">IN</h4>

<p>Lauseke <code class="language-html highlighter-rouge">x IN (...)</code> on tosi, jos <code class="language-html highlighter-rouge">x</code> on jokin annetuista arvoista. Esimerkiksi kysely</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">WHERE</span> <span class="n">nimi</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">'lanttu'</span><span class="p">,</span><span class="s1">'nauris'</span><span class="p">,</span><span class="s1">'selleri'</span><span class="p">);</span>
</code></pre></div></div>

<p>hakee tuotteet, joiden nimi on lanttu, nauris tai selleri.</p>

<h4 id="like">LIKE</h4>

<p>Lauseke <code class="language-html highlighter-rouge">s LIKE p</code> on tosi, jos merkkijono <code class="language-html highlighter-rouge">s</code> vastaa kuvausta <code class="language-html highlighter-rouge">p</code>. Kuvauksessa voi käyttää erikoismerkkejä <code class="language-html highlighter-rouge">_</code> (mikä tahansa yksittäinen merkki) sekä <code class="language-html highlighter-rouge">%</code> (mikä tahansa määrä mitä tahansa merkkejä). Esimerkiksi kysely</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">WHERE</span> <span class="n">nimi</span> <span class="k">LIKE</span> <span class="s1">'%ri%'</span><span class="p">;</span>
</code></pre></div></div>

<p>hakee tuotteet, joiden nimen osana esiintyy merkkijono “ri” (kuten nauris ja selleri).</p>

<h3 id="funktiot">Funktiot</h3>

<p>Lausekkeiden osana voi esiintyä myös funktioita samaan tapaan kuin ohjelmoinnissa. Tässä on esimerkkinä joitakin SQLiten funktioita:</p>

<ul>
  <li><code class="language-html highlighter-rouge">ABS(x)</code> antaa luvun <code class="language-html highlighter-rouge">x</code> itseisarvon</li>
  <li><code class="language-html highlighter-rouge">LENGTH(s)</code> antaa merkkijonon <code class="language-html highlighter-rouge">s</code> pituuden</li>
  <li><code class="language-html highlighter-rouge">LOWER(s)</code> muuttaa merkkijonon <code class="language-html highlighter-rouge">s</code> kirjaimet pieniksi</li>
  <li><code class="language-html highlighter-rouge">MAX(x,y)</code> antaa suuremman luvuista <code class="language-html highlighter-rouge">x</code> ja <code class="language-html highlighter-rouge">y</code></li>
  <li><code class="language-html highlighter-rouge">MIN(x,y)</code> antaa pienemmän luvuista <code class="language-html highlighter-rouge">x</code> ja <code class="language-html highlighter-rouge">y</code></li>
  <li><code class="language-html highlighter-rouge">RANDOM()</code> antaa satunnaisen luvun</li>
  <li><code class="language-html highlighter-rouge">ROUND(x,d)</code> antaa luvun <code class="language-html highlighter-rouge">x</code> pyöristettynä <code class="language-html highlighter-rouge">d</code> desimaalin tarkkuudelle</li>
  <li><code class="language-html highlighter-rouge">SUBSTR(s,a,b)</code> antaa merkkijonon <code class="language-html highlighter-rouge">s</code> kohdasta <code class="language-html highlighter-rouge">a</code> alkaen <code class="language-html highlighter-rouge">b</code> merkkiä</li>
  <li><code class="language-html highlighter-rouge">UPPER(s)</code> muuttaa merkkijonon <code class="language-html highlighter-rouge">s</code> kirjaimet suuriksi</li>
</ul>

<p>Esimerkiksi kysely</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">WHERE</span> <span class="k">LENGTH</span><span class="p">(</span><span class="n">nimi</span><span class="p">)</span><span class="o">=</span><span class="mi">6</span><span class="p">;</span>
</code></pre></div></div>

<p>hakee tuotteet, joiden nimessä on kuusi kirjainta (kuten lanttu ja nauris). Kysely</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">SUBSTR</span><span class="p">(</span><span class="n">nimi</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">SUBSTR</span><span class="p">(</span><span class="n">nimi</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>ryhmittelee tuotteet ensimmäisen kirjaimen mukaan ja ilmoittaa kullakin kirjaimella alkavien tuotteiden määrät. Kysely</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">RANDOM</span><span class="p">();</span>
</code></pre></div></div>

<p>puolestaan antaa rivit <em>satunnaisessa</em> järjestyksessä, koska järjestys ei perustu minkään sarakkeen sisältöön vaan satunnaiseen arvoon.</p>

<h4 id="order-by-ja-lausekkeet">ORDER BY ja lausekkeet</h4>

<p>Voisi kuvitella, että kyselyssä</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>rivit järjestetään lausekkeen <code class="language-html highlighter-rouge">1</code> mukaan. Koska lausekkeen arvo on joka rivillä <code class="language-html highlighter-rouge">1</code>, tämä ei tuottaisi mitään erityistä järjestystä. Näin ei kuitenkaan ole, vaan <code class="language-html highlighter-rouge">1</code> järjestää rivit ensimmäisen sarakkeen mukaan, <code class="language-html highlighter-rouge">2</code> toisen sarakkeen mukaan, jne. Tämä on siis vaihtoehtoinen tapa ilmaista sarake, johon järjestys perustuu.</p>

<p>Kuitenkin jos <code class="language-html highlighter-rouge">ORDER BY</code> -osassa oleva lauseke on jotain muuta kuin yksittäinen luku (kuten <code class="language-html highlighter-rouge">RANDOM()</code>), rivit järjestetään kyseisen lausekkeen mukaisesti.</p>

<h2 id="null-arvot">NULL-arvot</h2>

<p><code class="language-html highlighter-rouge">NULL</code> on erityinen arvo, joka ilmaisee, että taulun sarakkeessa ei ole tietoa tai jokin kyselyn osa ei tuottanut tietoa. <code class="language-html highlighter-rouge">NULL</code> on tietyissä tilanteissa kätevä, mutta voi aiheuttaa myös yllätyksiä.</p>

<p><code class="language-html highlighter-rouge">NULL</code> on selkeästi eri asia kuin luku 0. Jos <code class="language-html highlighter-rouge">NULL</code> esiintyy laskun osana, niin koko laskun tulokseksi tulee <code class="language-html highlighter-rouge">NULL</code>. SQLite-tulkki näyttää tällöin vain tyhjän rivin:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>SELECT NULL;

<span class="p">sqlite&gt; </span>SELECT 5+NULL;

<span class="p">sqlite&gt; </span>SELECT 2*NULL+1;

</code></pre></div></div>

<p>Myöskään tavallinen vertailu ei tuota tulosta, jos verrattavana on <code class="language-html highlighter-rouge">NULL</code>:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>SELECT 5 = NULL;

<span class="p">sqlite&gt; </span>SELECT 5 &lt;&gt; NULL;

</code></pre></div></div>

<p>Tämä on yllättävää, koska yleensä lausekkeille <code class="language-html highlighter-rouge">a</code> ja <code class="language-html highlighter-rouge">b</code> pätee joko <code class="language-html highlighter-rouge">a = b </code> tai <code class="language-html highlighter-rouge">a <span class="nt">&lt;&gt;</span> b</code>. Voimme kuitenkin tutkia erityisen syntaksin <code class="language-html highlighter-rouge">IS NULL</code> avulla, onko lausekkeen arvo <code class="language-html highlighter-rouge">NULL</code>:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>SELECT 5 IS NULL;
0
<span class="p">sqlite&gt; </span>SELECT NULL IS NULL;
1
</code></pre></div></div>

<h3 id="sarakkeen-puuttuva-tieto">Sarakkeen puuttuva tieto</h3>

<p><code class="language-html highlighter-rouge">NULL</code>-arvon yksi käyttötarkoitus on ilmaista, että jossain sarakkeessa ei ole tietoa. Esimerkiksi seuraavassa taulussa <code class="language-html highlighter-rouge">Elokuvat</code> Dumbon vuosi puuttuu, joten sen kohdalla on <code class="language-html highlighter-rouge">NULL</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        vuosi     
----------  ----------  ----------
1           Lumikki     1937      
2           Fantasia    1940      
3           Pinocchio   1940      
4           Dumbo                 
5           Bambi       1942  
</code></pre></div></div>

<p>Kun haemme ensin vuoden 1940 elokuvat ja sitten kaikki elokuvat muilta vuosilta, saamme seuraavat tulokset:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Elokuvat</span> <span class="k">WHERE</span> <span class="n">vuosi</span><span class="o">=</span><span class="mi">1940</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        vuosi     
----------  ----------  ----------
2           Fantasia    1940      
3           Pinocchio   1940      
</code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Elokuvat</span> <span class="k">WHERE</span> <span class="n">vuosi</span><span class="o">&lt;&gt;</span><span class="mi">1940</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        vuosi     
----------  ----------  ----------
1           Lumikki     1937      
5           Bambi       1942      
</code></pre></div></div>

<p>Koska Dumbolla ei ole vuotta, emme saa sitä kummassakaan kyselyssä, mikä on yllättävä ilmiö. Voimme kuitenkin hakea näin elokuvat, joilla ei ole vuotta:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Elokuvat</span> <span class="k">WHERE</span> <span class="n">vuosi</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        vuosi     
----------  ----------  ----------
4           Dumbo            
</code></pre></div></div>

<h3 id="null-arvo-koostefunktiossa">NULL-arvo koostefunktiossa</h3>

<p>Kun koostefunktion sisällä on lauseke (kuten sarake), riviä ei lasketa mukaan, jos lausekkeen arvo on <code class="language-html highlighter-rouge">NULL</code>. Tarkastellaan esimerkkinä seuraavaa taulua <code class="language-html highlighter-rouge">Tyontekijat</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        yritys      palkka    
----------  ----------  ----------  ----------
1           Anna        Google      8000      
2           Liisa       Google      7500      
3           Kaaleppi    Amazon            
4           Uolevi      Amazon      
5           Maija       Google      9500      
</code></pre></div></div>

<p>Taulussa Googlen työntekijöillä on ilmoitettu palkka, mutta Amazonin työntekijöillä ei. Koostefunktio <code class="language-html highlighter-rouge">COUNT(palkka)</code> laskee mukaan vain rivit, joissa palkka on ilmoitettu:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">palkka</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tyontekijat</span> <span class="k">WHERE</span> <span class="n">yritys</span><span class="o">=</span><span class="s1">'Google'</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>COUNT(palkka)
-------------
3

</code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">palkka</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tyontekijat</span> <span class="k">WHERE</span> <span class="n">yritys</span><span class="o">=</span><span class="s1">'Amazon'</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>COUNT(palkka)
-------------
0
</code></pre></div></div>

<p>Kun sitten laskemme palkkojen summia koostefunktiolla <code class="language-html highlighter-rouge">SUM(palkka)</code>, saamme seuraavat tulokset:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">palkka</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tyontekijat</span> <span class="k">WHERE</span> <span class="n">yritys</span><span class="o">=</span><span class="s1">'Google'</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>SUM(palkka)
-----------
25000      
</code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">palkka</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tyontekijat</span> <span class="k">WHERE</span> <span class="n">yritys</span><span class="o">=</span><span class="s1">'Amazon'</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>SUM(palkka)
-----------

</code></pre></div></div>

<p>Tämä on vähän yllättävää, koska voisi myös odottaa tyhjän summan olevan 0 eikä <code class="language-html highlighter-rouge">NULL</code>.</p>

<h3 id="null-arvon-muuttaminen">NULL-arvon muuttaminen</h3>

<p>Funktio <code class="language-html highlighter-rouge">IFNULL(a,b)</code> palauttaa arvon <code class="language-html highlighter-rouge">a</code>, jos <code class="language-html highlighter-rouge">a</code> ei ole <code class="language-html highlighter-rouge">NULL</code>, ja muuten arvon <code class="language-html highlighter-rouge">b</code>:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>SELECT IFNULL(5,0);
IFNULL(5,0)
-----------
5          
<span class="p">sqlite&gt; </span>SELECT IFNULL(NULL,0);
IFNULL(NULL,0)
--------------
0
</code></pre></div></div>

<p>Yllä oleva tapa on tyypillinen tapa käyttää funktiota: kun toinen parametri on 0, niin funktio muuttaa mahdollisen <code class="language-html highlighter-rouge">NULL</code>-arvon nollaksi. Tästä on hyötyä esimerkiksi <code class="language-html highlighter-rouge">LEFT JOIN</code> -kyselyissä
<code class="language-html highlighter-rouge">SUM</code>-funktion kanssa.</p>

<p>Yleisempi funktio on <code class="language-html highlighter-rouge">COALESCE(...)</code>, jolle annetaan lista arvoista. Funktio palauttaa listan ensimmäisen arvon, joka ei ole <code class="language-html highlighter-rouge">NULL</code>, tai arvon <code class="language-html highlighter-rouge">NULL</code>, jos jokainen arvo on <code class="language-html highlighter-rouge">NULL</code>. Jos funktiolla on kaksi parametria, se toimii samoin kuin <code class="language-html highlighter-rouge">IFNULL</code>.</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>SELECT COALESCE(1,2,3);
COALESCE(1,2,3)
---------------
1              
<span class="p">sqlite&gt; </span>SELECT COALESCE(NULL,2,3);
COALESCE(NULL,2,3)
------------------
2                 
<span class="p">sqlite&gt; </span>SELECT COALESCE(NULL,NULL,3);
COALESCE(NULL,NULL,3)
---------------------
3                    
<span class="p">sqlite&gt; </span>SELECT COALESCE(NULL,NULL,NULL);
COALESCE(NULL,NULL,NULL)
------------------------

</code></pre></div></div>

<h2 id="tulosrivien-rajaus">Tulosrivien rajaus</h2>

<p>Kun lisäämme kyselyn loppuun <code class="language-html highlighter-rouge">LIMIT x</code>, kysely antaa vain <code class="language-html highlighter-rouge">x</code> ensimmäistä tulosriviä. Esimerkiksi <code class="language-html highlighter-rouge">LIMIT 3</code> tarkoittaa, että kysely antaa kolme ensimmäistä tulosriviä.</p>

<p>Yleisempi muoto on <code class="language-html highlighter-rouge">LIMIT x OFFSET y</code>, mikä tarkoittaa, että haluamme <code class="language-html highlighter-rouge">x</code> riviä kohdasta <code class="language-html highlighter-rouge">y</code> alkaen (0-indeksoituna). Esimerkiksi <code class="language-html highlighter-rouge">LIMIT 3 OFFSET 1</code> tarkoittaa, että kysely antaa toisen, kolmannen ja neljännen tulosrivin.</p>

<p>Tarkastellaan esimerkkinä kyselyä, joka hakee tuotteita halvimmasta kalleimpaan:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">hinta</span><span class="p">;</span>
</code></pre></div></div>

<p>Kyselyn tuloksena on seuraava tulostaulu:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        hinta     
----------  ----------  ----------
3           nauris      2
5           selleri     4         
2           porkkana    5         
1           retiisi     7         
4           lanttu      8         
</code></pre></div></div>

<p>Saamme haettua kolme halvinta tuotetta seuraavasti:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">hinta</span> <span class="k">LIMIT</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></div></div>

<p>Kyselyn tulos on seuraava:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        hinta     
----------  ----------  ----------
3           nauris      2         
5           selleri     4         
2           porkkana    5      
</code></pre></div></div>

<p>Seuraava kysely puolestaan hakee kolme halvinta tuotetta toiseksi halvimmasta tuotteesta alkaen:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">hinta</span> <span class="k">LIMIT</span> <span class="mi">3</span> <span class="k">OFFSET</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>Tämän kyselyn tulos on seuraava:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        hinta     
----------  ----------  ----------
5           selleri     4         
2           porkkana    5         
1           retiisi     7    
</code></pre></div></div>

<h2 id="alikyselyt">Alikyselyt</h2>

<p><em>Alikysely</em> on SQL-komennon osana oleva lauseke, jonka arvo syntyy jonkin kyselyn perusteella.
Voimme rakentaa alikyselyjä samaan tapaan kuin varsinaisia kyselyjä ja toteuttaa niiden avulla hakuja, joita olisi vaikea saada aikaan muuten.</p>

<h3 id="esimerkki-8">Esimerkki</h3>

<p>Tarkastellaan esimerkkinä tilannetta, jossa tietokannassa on pelaajien tuloksia taulussa <code class="language-html highlighter-rouge">Tulokset</code>. Oletamme, että taulun sisältö on seuraava:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        tulos     
----------  ----------  ----------
1           Uolevi      120       
2           Maija       80        
3           Liisa       120       
4           Aapeli      45        
5           Kaaleppi    115    
</code></pre></div></div>

<p>Haluamme nyt selvittää ne pelaajat, jotka ovat saavuttaneet korkeimman tuloksen, eli kyselyn tulisi palauttaa Uolevi ja Liisa. Saamme tämän aikaan alikyselyllä seuraavasti:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">nimi</span><span class="p">,</span> <span class="n">tulos</span>
<span class="k">FROM</span>
  <span class="n">Tulokset</span>
<span class="k">WHERE</span>
  <span class="n">tulos</span> <span class="o">=</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">MAX</span><span class="p">(</span><span class="n">tulos</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tulokset</span><span class="p">);</span>
</code></pre></div></div>

<p>Kyselyn tuloksena on:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi        tulos     
----------  ----------
Uolevi      120       
Liisa       120       
</code></pre></div></div>

<p>Tässä kyselyssä alikysely on <code class="language-html highlighter-rouge">SELECT MAX(tulos) FROM Tulokset</code>, joka antaa suurimman taulussa olevan tuloksen eli tässä tapauksessa arvon 120. Huomaa, että alikysely tulee kirjoittaa sulkujen sisään, jotta se ei sekoitu pääkyselyyn.</p>

<h3 id="alikyselyn-laatiminen">Alikyselyn laatiminen</h3>

<p>Alikysely voi esiintyä melkein missä tahansa kohtaa kyselyssä, ja se voi tilanteesta riippuen palauttaa yksittäisen arvon, listan arvoista tai kokonaisen taulun.</p>

<h4 id="alikysely-sarakkeessa">Alikysely sarakkeessa</h4>

<p>Seuraavassa kyselyssä alikyselyn avulla luodaan kolmas sarake, joka näyttää pelaajan tuloksen eron ennätystulokseen:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">nimi</span><span class="p">,</span> <span class="n">tulos</span><span class="p">,</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">MAX</span><span class="p">(</span><span class="n">tulos</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tulokset</span><span class="p">)</span><span class="o">-</span><span class="n">tulos</span>
<span class="k">FROM</span>
  <span class="n">Tulokset</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi        tulos       (SELECT MAX(tulos) FROM Tulokset)-tulos
----------  ----------  ---------------------------------------
Uolevi      120         0                                      
Maija       80          40                                     
Liisa       120         0                                      
Aapeli      45          75                                     
Kaaleppi    115         5   
</code></pre></div></div>

<h4 id="alikysely-tauluna">Alikysely tauluna</h4>

<p>Seuraavassa kyselyssä alikysely luo taulun, jossa on kolme parasta tulosta.
Näiden tulosten summa (120+120+115) lasketaan pääkyselyssä.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="k">SUM</span><span class="p">(</span><span class="n">tulos</span><span class="p">)</span>
<span class="k">FROM</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tulokset</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">tulos</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">3</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>SUM(tulos)
----------
355
</code></pre></div></div>

<p>Tässä avainsana <code class="language-html highlighter-rouge">LIMIT</code> rajaa tulostaulua niin, että siinä on vain kolme ensimmäistä riviä.</p>

<p>Huomaa, että yhtä kyselyä käyttämällä saisimme väärän tuloksen:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">tulos</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tulokset</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">tulos</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>SUM(tulos)
----------
480     
</code></pre></div></div>

<p>Tässä tulostaulussa on vain yksi rivi, jossa on kaikkien tulosten summa (480). Niinpä kyselyn lopussa oleva <code class="language-html highlighter-rouge">LIMIT 3</code> ei vaikuta mitenkään tulokseen.</p>

<h4 id="alikysely-listana">Alikysely listana</h4>

<p>Seuraava kysely hakee pelaajat, joiden tulos kuuluu kolmen parhaimman joukkoon. Alikysely palauttaa listan tuloksista IN-lauseketta varten.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Tulokset</span>
<span class="k">WHERE</span>
  <span class="n">tulos</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">tulos</span> <span class="k">FROM</span> <span class="n">Tulokset</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">tulos</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">3</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi      
----------
Uolevi    
Liisa     
Kaaleppi  
</code></pre></div></div>

<h3 id="riippuva-alikysely">Riippuva alikysely</h3>

<p>Alikysely on mahdollista toteuttaa myös niin, että sen toiminta riippuu pääkyselyssä käsiteltävästä rivistä. Näin on seuraavassa kyselyssä:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">nimi</span><span class="p">,</span> <span class="n">tulos</span><span class="p">,</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tulokset</span> <span class="k">WHERE</span> <span class="n">tulos</span> <span class="o">&gt;</span> <span class="n">T</span><span class="p">.</span><span class="n">tulos</span><span class="p">)</span>
<span class="k">FROM</span>
  <span class="n">Tulokset</span> <span class="n">T</span><span class="p">;</span>
</code></pre></div></div>

<p>Tämän kysely laskee jokaiselle pelaajalle, monenko pelaajan tulos on parempi kuin pelaajan oma tulos. Esimerkiksi Maijalle vastaus on 3, koska Uolevin, Liisan ja Kaalepin tulos on parempi. Kysely antaa seuraavan tuloksen:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>nimi        tulos       (SELECT COUNT(*) FROM Tulokset WHERE tulos &gt; T.tulos)
----------  ----------  -----------------------------------------------------
Uolevi      120         0                                                    
Maija       80          3                                                    
Liisa       120         0                                                    
Aapeli      45          4                                                    
Kaaleppi    115         2                                                    
</code></pre></div></div>

<p>Koska taulu <code class="language-html highlighter-rouge">Tulokset</code> esiintyy kahdessa roolissa alikyselyssä, pääkyselyn taululle on annettu nimi <code class="language-html highlighter-rouge">T</code>. Tämän ansiosta alikyselyssä on selvää, että halutaan laskea rivejä, joiden tulos on parempi kuin pääkyselyssä käsiteltävän rivin tulos.</p>

<h3 id="milloin-käyttää-alikyselyä">Milloin käyttää alikyselyä?</h3>

<p>Melko usein alikysely on vaihtoehtoinen tapa toteuttaa kysely, jonka voisi tehdä jotenkin muutenkin. Esimerkiksi molemmat seuraavat kyselyt hakevat tuotteiden nimet asiakkaan 1 ostoskorissa:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">T</span><span class="p">.</span><span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Tuotteet</span> <span class="n">T</span><span class="p">,</span> <span class="n">Ostokset</span> <span class="n">O</span>
<span class="k">WHERE</span>
  <span class="n">T</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">tuote_id</span> <span class="k">AND</span> <span class="n">O</span><span class="p">.</span><span class="n">asiakas_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">nimi</span>
<span class="k">FROM</span>
  <span class="n">Tuotteet</span>
<span class="k">WHERE</span>
  <span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">tuote_id</span> <span class="k">FROM</span> <span class="n">Ostokset</span> <span class="k">WHERE</span> <span class="n">asiakas_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>Ensimmäinen kysely on tyypillinen kahden taulun kysely, kun taas toinen kysely valikoi tuotteet alikyselyn avulla. Kumpi kysely on parempi?</p>

<p>Ensimmäinen kysely on parempi, koska tämä on tarkoitettu tapa hakea SQL:ssä tietoa tauluista viittausten avulla. Toinen kysely toimii sinänsä, mutta se poikkeaa totutusta eikä tietokantajärjestelmä myöskään pysty ehkä suorittamaan sitä yhtä tehokkaasti.</p>

<p>Alikyselyä kannattaa käyttää vain silloin, kun siihen on todellinen syy. Jos kyselyn voi tehdä helposti usean taulun kyselyllä, tämä on yleensä parempi ratkaisu.</p>

<h2 id="lisää-tekniikoita">Lisää tekniikoita</h2>

<p>Tässä osiossa on lisää näytteitä SQL:n mahdollisuuksista. Näistä tekniikoista on hyötyä joidenkin SQL Trainerin vaikeiden tehtävien ratkaisemisessa.</p>

<h3 id="kumulatiivinen-summa">Kumulatiivinen summa</h3>

<p>Hyödyllinen taito SQL:ssä on osata laskea <em>kumulatiivinen summa</em> eli jokaiselle riville summa sarakkeen luvuista kyseiselle riville asti. Tarkastellaan esimerkiksi seuraavaa taulua:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          tulos
----------  ----------
1           200
2           100
3           400
4           100
</code></pre></div></div>

<p>Voimme laskea kumulatiivisen summan kahden taulun kyselyllä näin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">A</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">tulos</span><span class="p">)</span>
<span class="k">FROM</span>
  <span class="n">Tulokset</span> <span class="n">A</span><span class="p">,</span> <span class="n">Tulokset</span> <span class="n">B</span>
<span class="k">WHERE</span>
  <span class="n">B</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="p">.</span><span class="n">id</span>
<span class="k">GROUP</span> <span class="k">BY</span>
  <span class="n">A</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          SUM(B.tulos)
----------  ------------
1           200         
2           300         
3           700         
4           800       
</code></pre></div></div>

<p>Tässä on ideana, että summa lasketaan taulun <code class="language-html highlighter-rouge">A</code> riville ja taulusta <code class="language-html highlighter-rouge">B</code> haetaan kaikki rivit, joiden <code class="language-html highlighter-rouge">id</code> on pienempi tai sama kuin taulun <code class="language-html highlighter-rouge">A</code> rivillä. Halutut summat saadaan laskettua <code class="language-html highlighter-rouge">SUM</code>-funktiolla ryhmittelyn jälkeen.</p>

<p>Vastaavaa tekniikkaa voi käyttää muissakin tilanteissa, jos haluamme laskea tuloksen, joka riippuu jotenkin kaikista “pienemmistä” riveistä taulussa.</p>

<h3 id="sisäkkäiset-koosteet">Sisäkkäiset koosteet</h3>

<p>Tarkastellaan tilannetta, jossa haluamme selvittää, mikä on suurin määrä elokuvia, jotka ovat ilmestyneet samana vuonna. Esimerkiksi seuraavassa taulussa haluttu tulos on 2, koska vuonna 1940 ilmestyi kaksi elokuvaa.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        vuosi     
----------  ----------  ----------
1           Lumikki     1937      
2           Fantasia    1940      
3           Pinocchio   1940      
4           Dumbo       1941      
5           Bambi       1942      
</code></pre></div></div>

<p>Tämä on vähän hankalalta vaikuttava tilanne, koska meidän tulisi tehdä sisäkkäin kyselyt <code class="language-html highlighter-rouge">COUNT</code>, joka laskee ilmestymismääriä, ja sitten <code class="language-html highlighter-rouge">MAX</code>, joka hakee suurimman arvon. SQL ei salli kuitenkaan kyselyä <code class="language-html highlighter-rouge">SELECT MAX(COUNT(vuosi))</code> tai vastaavaa.</p>

<p>Voimme ottaa kuitenkin lähtökohdaksi kyselyn,
joka ryhmittelee elokuvat vuoden mukaan ja hakee jokaisesta ryhmästä
elokuvien määrän:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Elokuvat</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">vuosi</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>COUNT(*)  
----------
1         
2         
1         
1       
</code></pre></div></div>

<p>Näistä luvuista pitää vielä saada haettua suurin, mikä onnistuu alikyselyn avulla. Tässä tapauksessa kätevä tapa on käyttää alikyselyä niin, että sen tulos on pääkyselyn <code class="language-html highlighter-rouge">FROM</code>-osassa, jolloin alikysely luo taulun, josta pääkysely hakee tietoa:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="k">MAX</span><span class="p">(</span><span class="k">c</span><span class="p">)</span> <span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">c</span> <span class="k">FROM</span> <span class="n">Elokuvat</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">vuosi</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>MAX(c)    
----------
2       
</code></pre></div></div>

<p>Entä voisiko tehtävän ratkaista ilman alikyselyä? Kyllä, koska voimme järjestää tulokset suurimmasta pienimpään ja valita tulostaulun ensimmäisen rivin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">c</span> <span class="k">FROM</span> <span class="n">Elokuvat</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">vuosi</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="k">c</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>c         
----------
2          
</code></pre></div></div>

<h3 id="sijaluvut">Sijaluvut</h3>

<p>Tarkastellaan taulua, jossa on pelaajia ja heidän tuloksiaan:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        tulos     
----------  ----------  ----------
1           Aapeli      45        
2           Kaaleppi    115       
3           Liisa       120       
4           Maija       80        
5           Uolevi      120   
</code></pre></div></div>

<p>Tavoitteena on hakea rivit järjestyksessä tuloksen mukaan suurimmasta pienempään ja ilmoittaa lisäksi kunkin rivin <em>sijaluku</em>. Yksi tapa toteuttaa tämä on tehdä alikysely, joka laskee, monellako rivillä tulos on parempi, jolloin sija on yhtä suurempi kuin alikyselyn tulos:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tulokset</span> <span class="k">WHERE</span> <span class="n">tulos</span> <span class="o">&gt;</span> <span class="n">T</span><span class="p">.</span><span class="n">tulos</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="n">sija</span><span class="p">,</span> <span class="n">nimi</span><span class="p">,</span> <span class="n">tulos</span>
<span class="k">FROM</span>
  <span class="n">Tulokset</span> <span class="n">T</span>
<span class="k">ORDER</span> <span class="k">BY</span>
  <span class="n">tulos</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">nimi</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>sija        nimi        tulos     
----------  ----------  ----------
1           Liisa       120       
1           Uolevi      120       
3           Kaaleppi    115       
4           Maija       80        
5           Aapeli      45   
</code></pre></div></div>

<p>Samalla idealla voidaan laskea sijaluvut myös niin, että jokaisella on eri sija ja yhtä suuren tuloksen tapauksessa aakkosjärjestys ratkaisee sijan:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tulokset</span> <span class="k">WHERE</span> <span class="n">tulos</span> <span class="o">&gt;</span> <span class="n">T</span><span class="p">.</span><span class="n">tulos</span> <span class="k">OR</span> <span class="p">(</span><span class="n">tulos</span> <span class="o">=</span> <span class="n">T</span><span class="p">.</span><span class="n">tulos</span> <span class="k">AND</span> <span class="n">nimi</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">.</span><span class="n">nimi</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span> <span class="n">sija</span><span class="p">,</span> <span class="n">nimi</span><span class="p">,</span> <span class="n">tulos</span>
<span class="k">FROM</span>
  <span class="n">Tulokset</span> <span class="n">T</span>
<span class="k">ORDER</span> <span class="k">BY</span>
  <span class="n">tulos</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">nimi</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>sija        nimi        tulos     
----------  ----------  ----------
1           Liisa       120       
2           Uolevi      120       
3           Kaaleppi    115       
4           Maija       80        
5           Aapeli      45   
</code></pre></div></div>

<p>Vaihtoehtoinen tapa laskea sijalukuja on ikkunafunktio, jos käytetty tietokanta sallii sen. Esimerkiksi SQLiten uusissa versioissa ikkunafunktioiden <code class="language-html highlighter-rouge">RANK</code> ja <code class="language-html highlighter-rouge">ROW_NUMBER</code> avulla voidaan laskea vastaavat sijaluvut kuin äskeisissä esimerkeissä.</p>

<h3 id="listojen-vertailu">Listojen vertailu</h3>

<p>Tarkastellaan taulua, johon on tallennettu listojen sisältö. Esimerkiksi seuraavassa taulussa lista 1 sisältää luvut [2, 4, 5], lista 2 sisältää luvut [3, 5] ja lista 3 sisältää luvut [2, 4, 5]:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          lista_id    luku     
----------  ----------  ----------
1           1           2         
2           1           4         
3           1           5         
4           2           3         
5           2           5         
6           3           2         
7           3           4         
8           3           5     
</code></pre></div></div>

<p>Seuraava kysely laskee jokaiselle listaparille, montako <em>yhteistä</em> tulosta niillä on:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="n">A</span><span class="p">.</span><span class="n">lista_id</span><span class="p">,</span> <span class="n">B</span><span class="p">.</span><span class="n">lista_id</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">FROM</span>
  <span class="n">Listat</span> <span class="n">A</span><span class="p">,</span> <span class="n">Listat</span> <span class="n">B</span>
<span class="k">WHERE</span>
  <span class="n">A</span><span class="p">.</span><span class="n">luku</span><span class="o">=</span><span class="n">B</span><span class="p">.</span><span class="n">luku</span>
<span class="k">GROUP</span> <span class="k">BY</span>
  <span class="n">A</span><span class="p">.</span><span class="n">lista_id</span><span class="p">,</span> <span class="n">B</span><span class="p">.</span><span class="n">lista_id</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>lista_id    lista_id    COUNT(*)  
----------  ----------  ----------
1           1           3         
1           2           1         
1           3           3         
2           1           1         
2           2           2         
2           3           1         
3           1           3         
3           2           1         
3           3           3     
</code></pre></div></div>

<p>Tästä selviää, että esimerkiksi listoilla 1 ja 2 on yksi yhteinen luku (5) ja listoilla 1 ja 3 on kolme yhteistä lukua (2, 4, 5). Tällaista kyselyä laajentamalla voidaan vaikkapa vertailla, onko kahdella listalla täysin sama sisältö. Näin on silloin, kun listoilla on yhtä monta lukua ja yhteisten lukujen määrä on yhtä suuri kuin yksittäisen listan lukujen määrä.</p>

<h1 id="5-tietokannat-ohjelmoinnissa">5. Tietokannat ohjelmoinnissa</h1>

<h2 id="tietokannan-käyttäminen">Tietokannan käyttäminen</h2>

<p>Python-kielen standardikirjastossa on moduuli <code class="language-html highlighter-rouge">sqlite3</code>, jonka avulla voidaan käyttää SQLite-tietokantaa. Seuraava koodi on pohja tietokannan käyttämiselle:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="s">"testi.db"</span><span class="p">)</span>
<span class="n">db</span><span class="p">.</span><span class="n">isolation_level</span> <span class="o">=</span> <span class="bp">None</span>

<span class="c1"># tietokantakomennot
</span></code></pre></div></div>

<p>Koodi luo olion <code class="language-html highlighter-rouge">db</code>, jonka kautta voidaan käyttää tiedostossa <code class="language-html highlighter-rouge">testi.db</code> olevaa tietokantaa. Jos tiedostoa ei ole valmiina olemassa, tiedosto luodaan ja tietokanta on aluksi tyhjä.</p>

<p>Koodi myös määrittelee, että <code class="language-html highlighter-rouge">isolation_level</code> on <code class="language-html highlighter-rouge">None</code>, mikä tarkoittaa, että kun tietokantaan tehdään muutoksia, ne tulevat voimaan välittömästi samaan tapaan kuin SQLite-tulkissa.</p>

<h3 id="komentojen-suoritus">Komentojen suoritus</h3>

<p>Metodi <code class="language-html highlighter-rouge">execute</code> suorittaa halutun SQL-komennon tietokannassa. Esimerkiksi seuraavat komennot luovat taulun <code class="language-html highlighter-rouge">Tuotteet</code> ja lisäävät sinne kolme riviä:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"CREATE TABLE Tuotteet (id INTEGER PRIMARY KEY, nimi TEXT, hinta INTEGER)"</span><span class="p">)</span>

<span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"INSERT INTO Tuotteet (nimi, hinta) VALUES ('selleri', 5)"</span><span class="p">)</span>
<span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"INSERT INTO Tuotteet (nimi, hinta) VALUES ('nauris', 8)"</span><span class="p">)</span>
<span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"INSERT INTO Tuotteet (nimi, hinta) VALUES ('lanttu', 4)"</span><span class="p">)</span>
</code></pre></div></div>

<p>Samalla tavalla voidaan myös hakea tietoa tietokannasta. Metodi <code class="language-html highlighter-rouge">fetchall</code> antaa kyselyn tulokset listana, jossa jokaista tulostaulun riviä vastaa tuple:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">tuotteet</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"SELECT nimi, hinta FROM Tuotteet"</span><span class="p">).</span><span class="n">fetchall</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">tuotteet</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>[('selleri', 5), ('nauris', 8), ('lanttu', 4)]
</code></pre></div></div>

<p>Metodi <code class="language-html highlighter-rouge">fetchone</code> puolestaan palauttaa ensimmäisen tulosrivin tuplena. Tämä metodi on erityisen hyödyllinen kyselyissä, jotka palauttavat aina yhden rivin:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">hinta</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"SELECT MAX(hinta) FROM Tuotteet"</span><span class="p">).</span><span class="n">fetchone</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">hinta</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>(8,)
</code></pre></div></div>

<h3 id="parametrit">Parametrit</h3>

<p>Seuraava koodi kysyy käyttäjältä tuotteen nimeä ja ilmoittaa sitten tuotteen hinnan tai tiedon siitä, että tuotetta ei ole tietokannassa.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">nimi</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Tuotteen nimi: "</span><span class="p">)</span>
<span class="n">hinta</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"SELECT hinta FROM Tuotteet WHERE nimi=?"</span><span class="p">,</span> <span class="p">[</span><span class="n">nimi</span><span class="p">]).</span><span class="n">fetchone</span><span class="p">()</span>
<span class="k">if</span> <span class="n">hinta</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Hinta on"</span><span class="p">,</span> <span class="n">hinta</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Ei löytynyt"</span><span class="p">)</span>
</code></pre></div></div>

<p>Tässä käyttäjän antama tieto yhdistetään kyselyyn <em>parametrina</em>: kyselyssä tiedon kohdalla on merkki <code class="language-html highlighter-rouge">?</code> ja sen kohdalle tuleva arvo annetaan listassa. Esimerkiksi jos käyttäjä antaa nimen <code class="language-html highlighter-rouge">nauris</code>, kyselystä tulee <code class="language-html highlighter-rouge">SELECT hinta FROM Tuotteet WHERE nimi='nauris'</code>. Tästä näkee, että merkkijonon tapauksessa <code class="language-html highlighter-rouge">'</code>-merkit lisätään automaattisesti oikealla tavalla.</p>

<p>Seuraava koodi puolestaan lisää uuden tuotteen tietokantaan:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">nimi</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Tuotteen nimi: "</span><span class="p">)</span>
<span class="n">hinta</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Tuotteen hinta: "</span><span class="p">)</span>
<span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"INSERT INTO Tuotteet (nimi, hinta) VALUES (?, ?)"</span><span class="p">,</span> <span class="p">[</span><span class="n">nimi</span><span class="p">,</span> <span class="n">hinta</span><span class="p">])</span>
</code></pre></div></div>

<p>Kun parametreja on useita, ne tulevat listan arvoista samassa järjestyksessä.</p>

<p>Parametrien avulla tieto liitetään varmasti oikealla tavalla SQL-komennon osaksi. Esimerkiksi jos tuotteen nimi on <code class="language-html highlighter-rouge">Pepe's Drink</code>, nimessä esiintyy <code class="language-html highlighter-rouge">'</code>-merkki ja oikea tapa ilmoittaa nimi komennossa on <code class="language-html highlighter-rouge">'Pepe\'s Drink'</code>. Kun tieto annetaan parametrina, tämä muutos tehdään automaattisesti. Erityisesti web-sovelluksissa parametrien käyttäminen estää myös SQL-injektion, jossa pahantahtoinen käyttäjä yrittää muuttaa komennon rakennetta. Tutustumme aiheeseen tarkemmin kurssilla <a href="https://hy-tsoha.github.io/materiaali/">Tietokantasovellus</a>.</p>

<h3 id="virheenkäsittely">Virheenkäsittely</h3>

<p>Tietokannassa suoritettava komento saattaa epäonnistua. Esimerkiksi seuraava komento epäonnistuu, jos taulu <code class="language-html highlighter-rouge">Tuotteet</code> on jo olemassa:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"CREATE TABLE Tuotteet (id INTEGER PRIMARY KEY, nimi TEXT, hinta INTEGER)"</span><span class="p">)</span>
</code></pre></div></div>

<p>Tällöin ohjelman suoritus päättyy seuraavaan virheeseen:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>Traceback (most recent call last):
  File "testi.py", line 6, in <span class="nt">&lt;module&gt;</span>
    db.execute("CREATE TABLE Tuotteet (id INTEGER PRIMARY KEY, nimi TEXT, hinta INTEGER)")
sqlite3.OperationalError: table Tuotteet already exists
</code></pre></div></div>

<p>Virhe voidaan käsitellä myös Python-koodin puolella vaikkapa näin:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">try</span><span class="p">:</span>
    <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"CREATE TABLE Tuotteet (id INTEGER PRIMARY KEY, nimi TEXT, hinta INTEGER)"</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Taulua ei voitu luoda"</span><span class="p">)</span>
</code></pre></div></div>

<p>Tällöin ohjelman suoritus jatkuu eteenpäin eikä pääty virheeseen.</p>

<h3 id="lisätyn-rivin-id-numero">Lisätyn rivin id-numero</h3>

<p>Seuraava koodi ilmoittaa tietokantaan lisätyn rivin id-numeron:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">tulos</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"INSERT INTO Tuotteet (nimi, hinta) VALUES ('lanttu', 4)"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">tulos</span><span class="p">.</span><span class="n">lastrowid</span><span class="p">)</span>
</code></pre></div></div>

<p>Tästä on hyötyä, jos tietokantaan lisätään tämän jälkeen muita rivejä, joka viittaavat ensin lisättyyn riviin.</p>

<h2 id="käyttöliittymä">Käyttöliittymä</h2>

<p>Seuraava ohjelma toteuttaa käyttöliittymän, jonka avulla käyttäjä voi lisätä tietokantaan tuotteita, hakea tuotteen hinnan tai poistua ohjelmasta. Ohjelma olettaa, että tiedostossa <code class="language-html highlighter-rouge">testi.db</code> on valmiina olemassa taulu <code class="language-html highlighter-rouge">Tuotteet</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="s">"testi.db"</span><span class="p">)</span>
<span class="n">db</span><span class="p">.</span><span class="n">isolation_level</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">print</span><span class="p">(</span><span class="s">"1 - Lisää uusi tuote"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"2 - Hae tuotteen hinta"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"3 - Sulje ohjelma"</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">komento</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Anna komento: "</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">komento</span> <span class="o">==</span> <span class="s">"1"</span><span class="p">:</span>
        <span class="n">nimi</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Tuotteen nimi: "</span><span class="p">)</span>
        <span class="n">hinta</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Tuotteen hinta: "</span><span class="p">)</span>
        <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"INSERT INTO Tuotteet (nimi, hinta) VALUES (?,?)"</span><span class="p">,</span> <span class="p">[</span><span class="n">nimi</span><span class="p">,</span> <span class="n">hinta</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">komento</span> <span class="o">==</span> <span class="s">"2"</span><span class="p">:</span>
        <span class="n">nimi</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Tuotteen nimi: "</span><span class="p">)</span>
        <span class="n">hinta</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"SELECT hinta FROM Tuotteet WHERE nimi=?"</span><span class="p">,</span> <span class="p">[</span><span class="n">nimi</span><span class="p">]).</span><span class="n">fetchone</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">hinta</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Hinta on"</span><span class="p">,</span> <span class="n">hinta</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Ei löytynyt"</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">komento</span> <span class="o">==</span> <span class="s">"3"</span><span class="p">:</span>
        <span class="k">break</span>
</code></pre></div></div>

<p>Ohjelman suoritus voi näyttää seuraavalta:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>1 - Lisää uusi tuote
2 - Hae tuotteen hinta
3 - Sulje ohjelma
Anna komento: 2
Tuotteen nimi: selleri
Hinta on 5
Anna komento: 2
Tuotteen nimi: palsternakka
Ei löytynyt
Anna komento: 1
Tuotteen nimi: palsternakka
Tuotteen hinta: 9
Anna komento: 2 
Tuotteen nimi: palsternakka
Hinta on 9
Anna komento: 3
</code></pre></div></div>

<h3 id="koodin-rakenne-paremmaksi">Koodin rakenne paremmaksi</h3>

<p>Usein pidetään hyvänä, että tietokannan käsittely ja käyttöliittymän toteutus ovat toisistaan erillään ohjelmassa. Seuraava koodi toteuttaa tämän niin, että moduuli <code class="language-html highlighter-rouge">tuotteet.py</code> käsittelee tietokantaa ja moduuli <code class="language-html highlighter-rouge">main.py</code> on pääohjelma, joka näyttää käyttöliittymän.</p>

<p class="code-title">tuotteet.py</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="s">"testi.db"</span><span class="p">)</span>
<span class="n">db</span><span class="p">.</span><span class="n">isolation_level</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">lisaa_tuote</span><span class="p">(</span><span class="n">nimi</span><span class="p">,</span> <span class="n">hinta</span><span class="p">):</span>
    <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"INSERT INTO Tuotteet (nimi, hinta) VALUES (?,?)"</span><span class="p">,</span> <span class="p">[</span><span class="n">nimi</span><span class="p">,</span> <span class="n">hinta</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">hae_hinta</span><span class="p">(</span><span class="n">nimi</span><span class="p">):</span>
    <span class="n">hinta</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"SELECT hinta FROM Tuotteet WHERE nimi=?"</span><span class="p">,</span> <span class="p">[</span><span class="n">nimi</span><span class="p">]).</span><span class="n">fetchone</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">hinta</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hinta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div>

<p class="code-title">main.py</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kn">import</span> <span class="nn">tuotteet</span>

<span class="k">print</span><span class="p">(</span><span class="s">"1 - Lisää uusi tuote"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"2 - Hae tuotteen hinta"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"3 - Sulje ohjelma"</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">komento</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Anna komento: "</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">komento</span> <span class="o">==</span> <span class="s">"1"</span><span class="p">:</span>
        <span class="n">nimi</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Tuotteen nimi: "</span><span class="p">)</span>
        <span class="n">hinta</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Tuotteen hinta: "</span><span class="p">)</span>
        <span class="n">tuotteet</span><span class="p">.</span><span class="n">lisaa_tuote</span><span class="p">(</span><span class="n">nimi</span><span class="p">,</span> <span class="n">hinta</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">komento</span> <span class="o">==</span> <span class="s">"2"</span><span class="p">:</span>
        <span class="n">nimi</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Tuotteen nimi: "</span><span class="p">)</span>
        <span class="n">hinta</span> <span class="o">=</span> <span class="n">tuotteet</span><span class="p">.</span><span class="n">hae_hinta</span><span class="p">(</span><span class="n">nimi</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hinta</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Hinta on"</span><span class="p">,</span> <span class="n">hinta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Ei löytynyt"</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">komento</span> <span class="o">==</span> <span class="s">"3"</span><span class="p">:</span>
        <span class="k">break</span>
</code></pre></div></div>

<p>Tällaisessa toteutuksessa käyttöliittymässä ei näy mitään siitä, että tiedot tallennetaan nimenomaan SQLite-tietokantaan, vaan tallennustapaa voisi periaatteessa muuttaa ilman, että käyttöliittymään tulisi mitään muutoksia.</p>

<p>Laajemmassa sovelluksessa olisi mielekästä jakaa tietokannan käsittely useampaan tiedostoon. Tällaisia sovelluksia tehdään myöhemmillä tietojenkäsittelytieteen kursseilla.</p>

<h2 id="mitä-tehdä-missäkin">Mitä tehdä missäkin</h2>

<p>Tietokannan ja koodin puolella voi usein tehdä samantapaisia asioita. Esimerkiksi seuraavassa on kaksi tapaa etsiä kalleimman tuotteen hinta tietokannasta:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">kallein</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"SELECT MAX(hinta) FROM Tuotteet"</span><span class="p">).</span><span class="n">fetchone</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">hinnat</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"SELECT hinta FROM Tuotteet"</span><span class="p">).</span><span class="n">fetchall</span><span class="p">()</span>
<span class="n">kallein</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">hinnat</span><span class="p">)</span>
</code></pre></div></div>

<p>Ensimmäisessä tavassa haetaan kallein hinta tietokannan puolella SQL:n <code class="language-html highlighter-rouge">MAX</code>-funktiolla. Toisessa tavassa puolestaan haetaan tietokannasta kaikkien tuotteiden hinnat listaan ja etsitään sitten koodin puolella listan kallein hinta Pythonin <code class="language-html highlighter-rouge">max</code>-funktiolla.</p>

<p>Näistä kahdesta tavasta ensimmäinen tapa on selkeästi parempi: ei ole hyvä hakea turhaa tietoa koodin puolelle ja tehdä käsittelyä, jonka voi tehdä helposti myös tietokannassa.</p>

<p>Erityisesti kannattaa välttää tilannetta, jossa suoritetaan turhaan useita SQL-komentoja, vaikka vain yksi komento riittäisi. Esimerkiksi seuraavassa on huono tapa hakea tietokannasta jokaisen opettajan nimi ja kurssien määrä:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">opettajat</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"SELECT id, nimi FROM Opettajat"</span><span class="p">).</span><span class="n">fetchall</span><span class="p">()</span>
<span class="k">for</span> <span class="n">opettaja</span> <span class="ow">in</span> <span class="n">opettajat</span><span class="p">:</span>
    <span class="n">maara</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"SELECT COUNT(*) FROM Kurssit WHERE opettaja_id=?"</span><span class="p">,</span> <span class="p">[</span><span class="n">opettaja</span><span class="p">[</span><span class="mi">0</span><span class="p">]]).</span><span class="n">fetchone</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">opettaja</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">maara</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</code></pre></div></div>

<p>Koodi hakee ensin listaan kunkin opettajan id-numeron ja nimen ja sitten jokaisesta opettajasta erikseen niiden kurssien määrän, joita kyseinen opettaja opettaa. Koodi on kyllä toimiva mutta se tekee valtavasti turhaa työtä hakiessaan jokaisen tiedon erikseen. Parempi ratkaisu on muodostaa yksi kysely, joka hakee suoraan kaiken tarvittavan:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">tiedot</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"SELECT O.nimi, COUNT(*) FROM Opettajat O LEFT JOIN Kurssit K ON O.id = K.opettaja_id GROUP BY O.id"</span><span class="p">).</span><span class="n">fetchall</span><span class="p">()</span>
<span class="k">for</span> <span class="n">rivi</span> <span class="ow">in</span> <span class="n">tiedot</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">rivi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rivi</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></div>

<p>Tuloksena oleva kysely on monimutkaisempi, mutta sen avulla tietokantajärjestelmä voi optimoida kokonaisuutena halutun tiedon hakemisen ja toimittaa tiedon mahdollisimman tehokkaasti koodille.</p>

<p>Kuitenkaan tietokannan puolella ei kannata tehdä kaikkea, mikä on teoriassa mahdollista. Tästä esimerkkinä on seuraava koodi, joka hakee tietokannasta tuloslistan, jossa pelaajat on järjestettynä pistemäärän ja nimen mukaan. Tulostuksessa pelaajista näytetään myös sija (1, 2, 3, jne.) listalla.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">lista</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"SELECT nimi, pisteet FROM Tulokset ORDER BY pisteet DESC, nimi"</span><span class="p">).</span><span class="n">fetchall</span><span class="p">()</span>
<span class="n">sija</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">tulos</span> <span class="ow">in</span> <span class="n">lista</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">sija</span><span class="p">,</span> <span class="n">tulos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tulos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">sija</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Tässä tapauksessa pelaajien sijat lasketaan koodin puolella muuttujan <code class="language-html highlighter-rouge">sija</code> avulla. Olisi mahdollista laatia monimutkainen SQL-kysely, jonka tulostaulussa on myös sijat, mutta tässä tapauksessa siitä tuskin olisi hyötyä, koska sijat voi laskea helposti ja tehokkaasti myös koodin puolella. Tällaisen kyselyn laatiminen on kuitenkin kiinnostava teoreettinen haaste, erityisesti käyttämättä ikkunafunktioita.</p>

<h1 id="6-tietokannan-suunnittelu">6. Tietokannan suunnittelu</h1>

<h2 id="suunnittelun-periaatteet">Suunnittelun periaatteet</h2>

<p>Tietokannan suunnittelussa meidän tulee päättää tietokannan rakenne: mitä tauluja tietokannassa on sekä mitä sarakkeita kussakin taulussa on. Tähän on sinänsä suuri määrä mahdollisuuksia, mutta tuntemalla muutaman periaatteen pääsee pitkälle.</p>

<p>Hyvä tavoite suunnittelussa on, että tuloksena olevaa tietokantaa on mukavaa käyttää SQL-kielen avulla. Tietokannan rakenteen tulisi olla sellainen, että pystymme hakemaan ja muuttamaan tietoa näppärästi SQL-komennoilla.</p>

<p>Tietokannan suunnittelun periaatteet ovat hyödyllisiä ja johtavat usein toimiviin ratkaisuihin. Kuitenkin aina kannattaa miettiä, mikä periaatteissa on taustalla ja milloin kannattaa mahdollisesti tehdä toisin. Tavoitteen tulisi olla aina se, että tietokanta on käyttötarkoitukseen sopiva, eikä että noudatetaan periaatteita ilman omaa ajattelua.</p>

<h3 id="taulu-vs-luokka">Taulu vs. luokka</h3>

<p>Tietokannan taulu ja olio-ohjelmoinnin luokka ovat samantapaisia käsitteitä. Molemmissa on kyse siitä, että määrittelemme tiedon <em>tyypin</em>. Taulun sarakkeet muistuttavat luokan attribuutteja, ja taulun rivi vastaa luokasta luotua oliota.</p>

<p>Esimerkiksi seuraava SQL-komento ja Python-koodi vastaavat toisiaan:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Elokuvat</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> 
    <span class="n">nimi</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">vuosi</span> <span class="nb">INTEGER</span>
<span class="p">);</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">class</span> <span class="nc">Elokuva</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nimi</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">vuosi</span> <span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">nimi</span> <span class="o">=</span> <span class="n">nimi</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">vuosi</span> <span class="o">=</span> <span class="n">vuosi</span>
</code></pre></div></div>

<p>Huomaa, että luokassa ei ole attribuuttia <code class="language-html highlighter-rouge">id</code>, koska ohjelmoinnissa olioilla on viittaukset, joiden avulla ne voidaan yksilöidä.</p>

<p>Rivin lisääminen tietokannan tauluun vastaa uuden olion muodostamista luokasta. Esimerkiksi seuraavat komennot vastaavat toisiaan:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Elokuvat</span> <span class="p">(</span><span class="n">nimi</span><span class="p">,</span><span class="n">vuosi</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Lumikki'</span><span class="p">,</span><span class="mi">1937</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Elokuvat</span> <span class="p">(</span><span class="n">nimi</span><span class="p">,</span><span class="n">vuosi</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Fantasia'</span><span class="p">,</span><span class="mi">1940</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Elokuvat</span> <span class="p">(</span><span class="n">nimi</span><span class="p">,</span><span class="n">vuosi</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Pinocchio'</span><span class="p">,</span><span class="mi">1940</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span> <span class="o">=</span> <span class="n">Elokuva</span><span class="p">(</span><span class="s">"Lumikki"</span><span class="p">,</span><span class="mi">1937</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Elokuva</span><span class="p">(</span><span class="s">"Fantasia"</span><span class="p">,</span><span class="mi">1940</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">Elokuva</span><span class="p">(</span><span class="s">"Pinocchio"</span><span class="p">,</span><span class="mi">1940</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="yksi-vai-useita-tauluja">Yksi vai useita tauluja?</h3>

<p>Ohjelmoinnissa kaikki saman tyyppiset oliot perustuvat samaan luokkaan, ja vastaavasti periaatteena tietokannan suunnittelussa on, että kaikki saman tyyppiset rivit ovat <em>yhdessä</em> taulussa. Tämän ansiosta voimme käsitellä rivejä kätevästi SQL-komennoilla.</p>

<p>Esimerkiksi jos tietokannassa on elokuvia, hyvä ratkaisu on tallentaa kaikki elokuvat samaan tauluun <code class="language-html highlighter-rouge">Elokuvat</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        vuosi     
----------  ----------  ----------
1           Lumikki     1937      
2           Fantasia    1940      
3           Pinocchio   1940      
4           Dumbo       1941      
5           Bambi       1942    
</code></pre></div></div>

<p>Tästä taulusta voimme hakea esimerkiksi vuoden 1940 elokuvat näin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">nimi</span> <span class="k">FROM</span> <span class="n">Elokuvat</span> <span class="k">WHERE</span> <span class="n">vuosi</span><span class="o">=</span><span class="mi">1940</span><span class="p">;</span>
</code></pre></div></div>

<p>Mutta mitä kävisi, jos jakaisimmekin elokuvat moneen tauluun? Esimerkiksi voisimme jakaa elokuvat tauluihin vuosien mukaan. Tällöin taulussa <code class="language-html highlighter-rouge">Elokuvat1940</code> olisi vuoden 1940 elokuvat, ja voisimme hakea ne näin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">nimi</span> <span class="k">FROM</span> <span class="n">Elokuvat1940</span><span class="p">;</span>
</code></pre></div></div>

<p>Tällainen ratkaisu toimii niin kauan, kuin haluamme hakea vain tietyn vuoden elokuvia. Kuitenkin tietokanta muuttuu vaikeakäyttöiseksi heti, jos haluamme tehdä jotain muita hakuja. Esimerkiksi jos haluamme hakea kaikki elokuvat vuosilta 1940–1950, tarvitsemme useita kyselyjä:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">nimi</span> <span class="k">FROM</span> <span class="n">Elokuvat1940</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">nimi</span> <span class="k">FROM</span> <span class="n">Elokuvat1941</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">nimi</span> <span class="k">FROM</span> <span class="n">Elokuvat1942</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">SELECT</span> <span class="n">nimi</span> <span class="k">FROM</span> <span class="n">Elokuvat1950</span><span class="p">;</span>
</code></pre></div></div>

<p>Kuitenkin kun elokuvat ovat samassa taulussa, niin selviämme yhdellä kyselyllä:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">nimi</span> <span class="k">FROM</span> <span class="n">Elokuvat</span> <span class="k">WHERE</span> <span class="n">vuosi</span> <span class="k">BETWEEN</span> <span class="mi">1940</span> <span class="k">AND</span> <span class="mi">1950</span><span class="p">;</span>
</code></pre></div></div>

<p>Kun elokuvat ovat yhdessä taulussa, pystymme käsittelemään niitä monipuolisesti yksittäisillä SQL-komennoilla, mikä ei olisi mahdollista, jos tauluja olisi useita.</p>

<h3 id="viittausten-toteutus">Viittausten toteutus</h3>

<p>Ohjelmoinnissa olion sisällä voi olla viittaus toiseen olioon, ja vastaavasti tietokannan taulun rivillä voi olla viittaus toiseen riviin. Kun jokaisella taulun rivillä on pääavaimena id-numero, riveihin on kätevää viitata muualta.</p>

<h4 id="yksi-moneen--suhde">Yksi moneen -suhde</h4>

<p>Tarkastellaan tilannetta, jossa tallennamme tietokantaan kursseja ja opettajia. Taulujen välillä on yksi moneen -suhde: jokaisella kurssilla on yksi opettaja, kun taas yhdellä opettajalla voi olla monta kurssia. Pythonissa voisimme luoda luokat näin:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">class</span> <span class="nc">Opettaja</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nimi</span> <span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">nimi</span> <span class="o">=</span> <span class="n">nimi</span>

<span class="k">class</span> <span class="nc">Kurssi</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nimi</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">opettaja</span> <span class="p">:</span> <span class="n">Opettaja</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">nimi</span> <span class="o">=</span> <span class="n">nimi</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">opettaja</span> <span class="o">=</span> <span class="n">opettaja</span>
</code></pre></div></div>

<p>Vastaavasti voimme luoda tietokannan taulut näin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Opettajat</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> 
    <span class="n">nimi</span> <span class="nb">TEXT</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Kurssit</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">nimi</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">opettaja_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Opettajat</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Taulussa <code class="language-html highlighter-rouge">Kurssit</code> sarake <code class="language-html highlighter-rouge">opettaja_id</code> viittaa tauluun <code class="language-html highlighter-rouge">Opettajat</code>, eli siinä on jonkin opettajan id-numero. Ilmaisemme viittauksen <code class="language-html highlighter-rouge">REFERENCES</code>-määreellä, joka kertoo, että sarakkeessa oleva kokonaisluku viittaa nimenomaan tauluun <code class="language-html highlighter-rouge">Opettajat</code>.</p>

<p>Voisimme laittaa tauluihin tietoa vaikkapa seuraavasti:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Opettajat</span> <span class="p">(</span><span class="n">nimi</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Kaila'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Opettajat</span> <span class="p">(</span><span class="n">nimi</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Kivinen'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Opettajat</span> <span class="p">(</span><span class="n">nimi</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Laaksonen'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Kurssit</span> <span class="p">(</span><span class="n">nimi</span><span class="p">,</span> <span class="n">opettaja_id</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Ohjelmoinnin perusteet'</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Kurssit</span> <span class="p">(</span><span class="n">nimi</span><span class="p">,</span> <span class="n">opettaja_id</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Ohjelmoinnin jatkokurssi'</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Kurssit</span> <span class="p">(</span><span class="n">nimi</span><span class="p">,</span> <span class="n">opettaja_id</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Tietokantojen perusteet'</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Kurssit</span> <span class="p">(</span><span class="n">nimi</span><span class="p">,</span> <span class="n">opettaja_id</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Tietorakenteet ja algoritmit'</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="monta-moneen--suhde">Monta moneen -suhde</h4>

<p>Tarkastellaan sitten tilannetta, jossa useampi opettaja voi järjestää kurssin yhteisesti. Tällöin kyseessä on monta moneen -suhde, koska kurssilla voi olla monta opettajaa ja opettajalla voi olla monta kurssia.</p>

<p>Pythonissa voisimme toteuttaa tämän muutoksen helposti muuttamalla luokkaa <code class="language-html highlighter-rouge">Kurssi</code> niin, että siinä on yhden opettajan sijasta lista opettajista:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">class</span> <span class="nc">Kurssi</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nimi</span> <span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">nimi</span> <span class="o">=</span> <span class="n">nimi</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">opettajat</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="k">def</span> <span class="nf">lisaa_opettaja</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opettaja</span> <span class="p">:</span> <span class="n">Opettaja</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">opettajat</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">opettaja</span><span class="p">)</span>
</code></pre></div></div>

<p>Tietokannoissa tilanne on kuitenkin toinen, koska emme voi tallentaa järkevästi taulun sarakkeeseen listaa viittauksista. Tämän sijasta meidän täytyy luoda uusi taulu viittauksille:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Opettajat</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">nimi</span> <span class="nb">TEXT</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Kurssit</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">nimi</span> <span class="nb">TEXT</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">KurssinOpettajat</span> <span class="p">(</span>
    <span class="n">kurssi_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Kurssit</span><span class="p">,</span>
    <span class="n">opettaja_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Opettaja</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Muutoksena on, että taulussa <code class="language-html highlighter-rouge">Kurssit</code> ei ole enää viittausta tauluun <code class="language-html highlighter-rouge">Opettajat</code>, mutta sen sijaan tietokannassa on uusi taulu <code class="language-html highlighter-rouge">KurssinOpettajat</code>, joka viittaa kumpaankin tauluun. Jokainen rivi tässä rivissä kuvaa yhden suhteen muotoa “kurssilla <em>x</em> opettaa opettaja <em>y</em>”.</p>

<p>Esimerkiksi voisimme ilmaista näin, että kurssilla on kaksi opettajaa:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Opettajat</span> <span class="p">(</span><span class="n">nimi</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Kivinen'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Opettajat</span> <span class="p">(</span><span class="n">nimi</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Laaksonen'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Kurssit</span> <span class="p">(</span><span class="n">nimi</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Tietorakenteet ja algoritmit'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">KurssinOpettajat</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">KurssinOpettajat</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div></div>

<p>Huomaa, että voisimme käyttää tätä ratkaisua myös aiemmassa tilanteessa, jossa kurssilla on aina tasan yksi opettaja, joskin tietokannassa olisi silloin tavallaan turha taulu.</p>

<h2 id="tiedon-atomisuus">Tiedon atomisuus</h2>

<p><em>Periaate</em>:
Tietokannan taulun jokaisessa sarakkeessa on yksittäinen eli <em>atominen</em> tieto, kuten yksi luku tai yksi merkkijono. Sarakkeessa ei saa olla listaa tiedoista.</p>

<p>Tämä periaate helpottaa tietokannan käsittelyä SQL-komentojen avulla: kun jokainen tieto on omassa sarakkeessaan, niin pystymme viittaamaan tietoon kätevästi komennoissa.</p>

<p>Kun tietokantaan halutaan tallentaa listoja, luodaan uusi taulu, jossa jokainen rivi on jonkin listan yksittäinen alkio, kuten äskeinen taulu <code class="language-html highlighter-rouge">KurssinOpettajat</code>. Mutta miksi emme voisi vain tallentaa listaa yhteen sarakkeeseen? Seuraava esimerkki selventää asiaa.</p>

<h3 id="esimerkki-9">Esimerkki</h3>

<h4 id="vaihe-1">Vaihe 1</h4>

<p>Haluamme tallentaa tietokantaan opiskelijoiden tenttituloksia. Tentissä on neljä tehtävää, joista voi saada 0–6 pistettä. Voisimme koettaa tallentaa pisteet näin:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          opiskelija_id  pisteet   
----------  -------------  ----------
1           1              6,5,1,4   
2           2              3,6,6,6   
3           3              6,4,0,6  
</code></pre></div></div>

<p>Ideana on, että sarakkeessa <code class="language-html highlighter-rouge">pisteet</code> on merkkijono, jossa on lista pisteistä pilkuilla erotettuina. Tämä ratkaisu kuitenkin rikkoo periaatetta, että jokaisessa sarakkeessa on yksittäinen tieto. Mitä vikaa ratkaisussa on?</p>

<p>Ratkaisun ongelmana on, että meidän on vaivalloista koettaa päästä pisteisiin käsiksi SQL-komennoissa, koska pisteet ovat merkkijonon sisällä. Esimerkiksi jos haluamme laskea jokaisen opiskelijan yhteispisteet, tarvitsemme seuraavan tapaisen kyselyn:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">opiskelija_id</span><span class="p">,</span> <span class="n">SUBSTR</span><span class="p">(</span><span class="n">pisteet</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span>
                      <span class="n">SUBSTR</span><span class="p">(</span><span class="n">pisteet</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span>
                      <span class="n">SUBSTR</span><span class="p">(</span><span class="n">pisteet</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span>
                      <span class="n">SUBSTR</span><span class="p">(</span><span class="n">pisteet</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tulokset</span><span class="p">;</span>
</code></pre></div></div>

<p>Tässä funktio <code class="language-html highlighter-rouge">SUBSTR</code> erottaa merkkijonosta tietyssä kohdassa olevan osajonon. Kysely on kuitenkin hankala ja lisäksi toimii vain, kun pisteitä on tasan neljä ja ne ovat yksinumeroisia. Tarvitsemme paremman tavan tallentaa pisteet.</p>

<h4 id="vaihe-2">Vaihe 2</h4>

<p>Seuraavassa taulussa pisteille on neljä saraketta, jolloin voimme käsitellä niitä yksitellen:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          opiskelija_id  pisteet1    pisteet2    pisteet3    pisteet4  
----------  -------------  ----------  ----------  ----------  ----------
1           1              6           5           1           4         
2           2              3           6           6           6         
3           3              6           4           0           6     
</code></pre></div></div>

<p>Tämän ansiosta saamme jo toteutettua kyselyn mukavammin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">opiskelija_id</span><span class="p">,</span> <span class="n">pisteet1</span><span class="o">+</span><span class="n">pisteet2</span><span class="o">+</span><span class="n">pisteet3</span><span class="o">+</span><span class="n">pisteet4</span> <span class="k">FROM</span> <span class="n">Tulokset</span><span class="p">;</span>
</code></pre></div></div>

<p>Tämä ratkaisu on selkeästi parempaan suuntaan, mutta siinä on edelleen ongelmia. Vaikka pisteet ovat eri sarakkeissa, oletuksena on edelleen, että tehtäviä on tasan neljä. Jos tehtävien määrä muuttuu, joudumme muuttamaan taulun rakennetta ja kaikkia pisteisiin liittyviä SQL-komentoja, mikä ei ole hyvä tilanne.</p>

<h4 id="vaihe-3">Vaihe 3</h4>

<p>Kun haluamme tallentaa listan tietokantaan, hyvä ratkaisu on tallentaa jokainen listan alkio omalle rivilleen. Tämän esimerkin tapauksessa voimme luoda taulun, jonka jokainen rivi ilmaisee tietyn opiskelijan pisteet tietyssä tehtävässä:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          opiskelija_id  tehtava_id  pisteet   
----------  -------------  ----------  ----------
1           1              1           6         
2           1              2           5         
3           1              3           1         
4           1              4           4         
5           2              1           3         
6           2              2           6         
7           2              3           6         
8           2              4           6         
9           3              1           6         
10          3              2           4         
11          3              3           0         
12          3              4           6
</code></pre></div></div>

<p>Nyt voimme hakea kunkin opiskelijan yhteispisteet näin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">opiskelija_id</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">pisteet</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Tulokset</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">opiskelija_id</span><span class="p">;</span>
</code></pre></div></div>

<p>Tämä on <em>yleiskäyttöinen</em> kysely eli se toimii yhtä hyvin riippumatta tehtävien määrästä. Pystymme hyödyntämään summan laskemisessa funktiota <code class="language-html highlighter-rouge">SUM</code> sen sijaan, että meidän tulisi luetella kaikki tehtävät itse.</p>

<p>Huomaa, että muutoksen seurauksena taulun rivien määrä kasvoi selvästi. Tätä ei kannata kuitenkaan hätkähtää: tietokantajärjestelmät on toteutettu niin, että ne toimivat hyvin, vaikka taulussa olisi paljon rivejä.</p>

<h3 id="mikä-on-atomista-tietoa">Mikä on atomista tietoa?</h3>

<p>Atomisen tiedon käsite ei ole hyvin määritelty. Selkeästi lista ei ole atominen tieto, mutta onko sitten vaikka merkkijonokaan, jossa on useita sanoja?</p>

<p>Tarkastellaan esimerkkinä tilannetta, jossa taulun sarakkeessa on käyttäjän nimi. Onko tämä huonoa suunnittelua, koska samassa sarakkeessa on etu- ja sukunimi?</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi         
----------  --------------
1           Anna Virtanen
2           Maija Korhonen
3           Pasi Lahtinen
</code></pre></div></div>

<p>Voisimme myös tallentaa etu- ja sukunimen erikseen näin:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          etunimi     sukunimi  
----------  ----------  ----------
1           Anna        Virtanen
2           Maija       Korhonen
3           Pasi        Lahtinen
</code></pre></div></div>

<p>Riippuu tilanteesta, kumpi taulu on parempi. Jos järjestelmässä on erityisesti tarvetta etsiä tietoa etu- tai sukunimen perusteella (esimerkiksi etsiä kaikki käyttäjät, joiden etunimi on Anna), jälkimmäinen taulu on parempi. Kuitenkaan usein ei ole näin eikä ole mitään pahaa tallentaa samaan sarakkeeseen etu- ja sukunimi.</p>

<p>Vastaavasti jos tietokantaan tallennetaan käyttäjän lähettämä viesti, siinä voi olla monia sanoja eli tavallaan viesti on lista sanoja, mutta on silti hyvä ratkaisu tallentaa koko viesti yhteen sarakkeeseen, koska viestiä käsitellään tietokannassa yhtenä kokonaisuutena. Olisi hyvin huono ratkaisu jakaa “atomisesti” viestin sanat omiin sarakkeisiin.</p>

<p>Kannattaakin ajatella asiaa niin, että jos jotain tietoa on tarvetta käsitellä erillisenä SQL-komennoissa, niin se on atominen tieto, jonka tulee olla omassa sarakkeessa. Jos taas tietoon ei viitata SQL-komennoissa, se voi olla sarakkeessa osana laajempaa kokonaisuutta.</p>

<h2 id="toisteinen-tieto">Toisteinen tieto</h2>

<p><em>Periaate</em>:
Jokainen tieto on tasan yhdessä paikassa tietokannassa. Tietokannassa ei ole tietoa, jonka voi laskea tai päätellä tietokannan muun sisällön perusteella.</p>

<p>Tätä periaatetta seuraamalla tietokannan sisällön päivittäminen on helppoa, koska päivitys riittää tehdä yhteen paikkaan eikä se vaikuta tietokannan muihin osiin.</p>

<h3 id="esimerkki-1">Esimerkki 1</h3>

<p>Tallennamme järjestelmään käyttäjien lähettämiä viestejä seuraavasti tauluun <code class="language-html highlighter-rouge">Viestit</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          kayttaja    viesti     
----------  ----------  --------------
1           Anna123     Missä olet?
2           Joulupukki  Bussissa vielä
3           Anna123     Meneekö kauan?
4           Joulupukki  5 min   
</code></pre></div></div>

<p>Tämä on muuten toimiva ratkaisu, mutta tietokannan sisältöä on hankalaa päivittää, jos käyttäjä päättää vaihtaa nimeään. Esimerkiksi jos Anna123 haluaa muuttaa nimeään, muutos täytyy tehdä jokaiseen viestiin, jonka hän on lähettänyt.</p>

<p>Parempi ratkaisu on toteuttaa tietokanta niin, että käyttäjän nimi on vain yhdessä paikassa. Luonteva paikka tälle on taulu <code class="language-html highlighter-rouge">Kayttajat</code>, joka sisältää käyttäjät:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi
----------  ----------
1           Anna123
2           Joulupukki
</code></pre></div></div>

<p>Muissa tauluissa on vain viitteenä käyttäjän id-numero, joka on muuttumaton tieto. Esimerkiksi taulu <code class="language-html highlighter-rouge">Viestit</code> näyttää nyt tältä:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          kayttaja_id  viesti     
----------  -----------  --------------
1           1            Missä olet?
2           2            Bussissa vielä
3           1            Meneekö kauan?
4           2            5 min   
</code></pre></div></div>

<p>Tämän jälkeen käyttäjän nimen muuttaminen on helppoa, koska muutos riittää tehdä taulun <code class="language-html highlighter-rouge">Kayttajat</code> yhteen riviin ja muutos päivittyy heti kaikkialle, koska muissa tauluissa viitataan edelleen oikeaan riviin.</p>

<p>Tämä monimutkaistaa kyselyjä, koska meidän täytyy hakea tietoa useista tauluista, mutta ratkaisu on kuitenkin kokonaisuuden kannalta hyvä.</p>

<h4 id="vieläkin-toisteisuutta">Vieläkin toisteisuutta?</h4>

<p>Äskeisestä muutoksesta huolimatta tietokannassa saattaa esiintyä edelleen toisteisuutta. Esimerkiksi seuraavassa tilanteessa käyttäjät lähettävät samanlaisen viestin “Hei!”. Pitäisikö tietokannan rakennetta parantaa?</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          kayttaja_id  viesti
----------  -----------  --------------
1           1            Hei!
2           2            Hei!
</code></pre></div></div>

<p>Tässä tapauksessa <em>ei</em> olisi hyvä idea toteuttaa tietokantaa niin, että jos kaksi käyttäjää lähettää saman sisältöisen viestin, viestin sisältö tallennetaan vain yhteen paikkaan.</p>

<p>Vaikka viesteissä on sama sisältö, ne ovat erillisiä viestejä, joiden ei ole tarkoitus viitata samaan asiaan. Jos käyttäjä 1 muuttaa viestin sisältöä, muutoksen ei tule heijastua käyttäjän 2 viestiin, vaikka siinä sattuu olemaan tällä hetkellä sama sisältö.</p>

<h3 id="esimerkki-2">Esimerkki 2</h3>

<p>Tallennamme tietokantaan tietoa opiskelijoiden suorituksista. Tietokannasta voidaan kysyä, montako opintopistettä opiskelija on suorittanut.</p>

<p>Seuraavassa tietokannassa jokaisen opiskelijan yhteyteen on tallennettu tieto, montako opintopistettä hän on suorittanut. Taulun <code class="language-html highlighter-rouge">Opiskelijat</code> sisältönä on:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi        op        
----------  ----------  ----------
1           Maija       20        
2           Uolevi      10   
</code></pre></div></div>

<p>Taulussa <code class="language-html highlighter-rouge">Suoritukset</code> puolestaan on seuraavat rivit:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          opiskelija_id  kurssi_id   op        
----------  -------------  ----------  ----------
1           1              1           5         
2           1              2           5         
3           1              4           10        
4           2              1           5         
5           2              3           5         
</code></pre></div></div>

<p>Tämän ansiosta on helppoa hakea opiskelijan opintopisteiden yhteismäärä:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">op</span> <span class="k">FROM</span> <span class="n">Opiskelijat</span> <span class="k">WHERE</span> <span class="n">nimi</span><span class="o">=</span><span class="s1">'Maija'</span><span class="p">;</span>
</code></pre></div></div>

<p>Kuitenkin tietokannassa on toisteista tietoa: taulun <code class="language-html highlighter-rouge">Opiskelijat</code> sarakkeen <code class="language-html highlighter-rouge">op</code> sisältö voidaan laskea taulun <code class="language-html highlighter-rouge">Suoritukset</code> avulla. Ongelmana on, että jos lisäämme tai poistamme suorituksen, niin joudumme tekemään muutoksen kahteen eri tauluun. Jos muutos unohtuu tehdä tai epäonnistuu, tietokantaan tulee ristiriitaista tietoa.</p>

<p>Pääsemme eroon toisteisesta tiedosta poistamalla sarakkeen <code class="language-html highlighter-rouge">op</code> taulusta <code class="language-html highlighter-rouge">Opiskelijat</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>id          nimi       
----------  ---------- 
1           Maija     
2           Uolevi    
</code></pre></div></div>

<p>Tämän muutoksen seurauksena on vaikeampaa selvittää opiskelijan opintopisteet, koska meidän täytyy laskea tieto suorituksista lähtien:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span>
  <span class="k">SUM</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">op</span><span class="p">)</span>
<span class="k">FROM</span>
  <span class="n">Suoritukset</span> <span class="n">S</span><span class="p">,</span> <span class="n">Opiskelijat</span> <span class="n">O</span>
<span class="k">WHERE</span>
  <span class="n">S</span><span class="p">.</span><span class="n">opiskelija_id</span><span class="o">=</span><span class="n">O</span><span class="p">.</span><span class="n">id</span> <span class="k">AND</span> <span class="n">O</span><span class="p">.</span><span class="n">nimi</span><span class="o">=</span><span class="s1">'Maija'</span><span class="p">;</span>
</code></pre></div></div>

<p>Tämä on kuitenkin kokonaisuutena hyvä muutos, koska nyt voimme huoletta muutella suorituksia ja luottaa siihen, että saamme aina haettua oikean tiedon opiskelijan opintopisteistä.</p>

<h3 id="muutokset-vs-kyselyt">Muutokset vs. kyselyt</h3>

<p>Vaikka ihanteena on, että tietokannassa ei ole toisteista tietoa, joskus kuitenkin toisteista tietoa tarvitaan hakujen tehostamiseksi. Toisteinen tieto vaikeuttaa tietokannan muuttamista mutta helpottaa kyselyjen tekemistä.</p>

<p>Usein esiintyvä ilmiö tietojenkäsittelytieteessä on, että joudumme tasapainoilemaan sen kanssa,
haluammeko muuttaa vai hakea tehokkaasti tietoa ja paljonko tilaa voimme käyttää. Tämä tulee tietokantojen lisäksi vastaan esimerkiksi algoritmien suunnittelussa.</p>

<p>Jos tietokannassa ei ole toisteista tietoa, muutokset ovat helppoja, koska jokainen tieto on vain yhdessä paikassa eli riittää muuttaa vain yhden taulun yhtä riviä. Myös hyvänä puolena tietokanta vie vähän tilaa. Toisaalta kyselyt voivat olla monimutkaisia ja hitaita, koska halutut tiedot pitää kerätä kasaan eri puolilta tietokantaa.</p>

<p>Kun sitten lisäämme toisteista tietoa, pystymme nopeuttamaan kyselyjä mutta toisaalta muutokset hidastuvat, koska muutettu tieto pitää päivittää useaan paikkaan. Samaan aikaan myös tietokannan tilankäyttö kasvaa toisteisen tiedon takia.</p>

<p>Ei ole mitään yleistä sääntöä, paljonko toisteista tietoa kannattaa lisätä, vaan tämä riippuu tietokannan sisällöstä ja halutuista kyselyistä. Yksi hyvä tapa on aloittaa tilanteesta, jossa toisteista tietoa ei ole, ja lisätä sitten toisteista tietoa tarvittaessa, jos osoittautuu, että kyselyt eivät muuten ole riittävän tehokkaita.</p>

<h2 id="suunnitteluesimerkki">Suunnitteluesimerkki</h2>

<p>Tarkastellaan lopuksi laajempaa esimerkkiä, jossa tavoitteemme on suunnitella tietokanta Facebookin kaltaista yhteisöpalvelua varten. Tietokannan tulee mahdollistaa seuraavat toiminnot:</p>

<ul>
  <li>Käyttäjä voi kirjautua palveluun antamalla sähköpostiosoitteen ja salasanan.</li>
  <li>Käyttäjällä on oma sivu, johon hän voi lähettää päivityksiä.</li>
  <li>Käyttäjä voi lisätä profiiliinsa tietoa, kuten nimen, syntymäpäivän, asuinpaikan, jne.</li>
  <li>Käyttäjä voi ystävystyä muiden palvelun käyttäjien kanssa.</li>
  <li>Käyttäjä voi lähettää palveluun valokuvia ja valita yhden niistä profiilikuvaksi.</li>
  <li>Käyttäjät voivat tykätä ja kommentoida toistensa päivityksiä ja kuvia.</li>
  <li>Käyttäjät voivat lähettää toisilleen yksityisviestejä.</li>
  <li>Palvelussa on myös ylläpitäjiä, joilla on enemmän oikeuksia kuin muilla käyttäjillä.</li>
</ul>

<h3 id="suunnittelun-vaiheet">Suunnittelun vaiheet</h3>

<p>Tietokannan suunnittelu etenee yleensä pikkuhiljaa niin, että tietokantaan lisätään uusia tauluja ja sarakkeita aina, kun uusissa toiminnoissa on tarvetta niille.</p>

<p>Seuraavaksi näemme, miten esimerkkitietokanta rakentuu vaihe vaiheelta vaadittujen toimintojen perusteella.</p>

<h4 id="kirjautuminen-palveluun">Kirjautuminen palveluun</h4>

<ul>
  <li>Käyttäjä voi kirjautua palveluun antamalla sähköpostiosoitteen ja salasanan.</li>
</ul>

<p>Tämä on hyvin tavallinen toiminto, josta on hyvä aloittaa tietokannan suunnittelu. Tarvitsemme taulun, jossa on käyttäjän tunnus (sähköpostiosoite) ja salasana:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Kayttajat</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">tunnus</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">salasana</span> <span class="nb">TEXT</span>
<span class="p">);</span>
</code></pre></div></div>

<h4 id="päivitykset-omalle-sivulle">Päivitykset omalle sivulle</h4>

<ul>
  <li>Käyttäjällä on oma sivu, johon hän voi lähettää päivityksiä.</li>
</ul>

<p>Tätä toimintoa varten tietokantaan täytyy pystyä tallentamaan käyttäjän päivityksiä. Hyvä ratkaisu on luoda taulu, joka sisältää kaikkien käyttäjien päivitykset id-numeron mukaan:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Paivitykset</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">kayttaja_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span><span class="p">,</span>
    <span class="n">viesti</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">aika</span> <span class="nb">DATETIME</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Huomaa, että tietokantaan ei tarvitse tallentaa tietoa käyttäjän sivusta. Jokaisella käyttäjällä on sivu, joka sisältää käyttäjän päivitykset, mutta sivuun itsessään ei liity tietoa.</p>

<h4 id="profiilin-tiedot">Profiilin tiedot</h4>

<ul>
  <li>Käyttäjä voi lisätä profiiliinsa tietoa, kuten nimen, syntymäpäivän, asuinpaikan, jne.</li>
</ul>

<p>Yksi tapa toteuttaa tämä toiminto olisi laajentaa taulua <code class="language-html highlighter-rouge">Kayttajat</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Kayttajat</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">tunnus</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">salasana</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">nimi</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">syntymapaiva</span> <span class="nb">DATE</span><span class="p">,</span>
    <span class="n">asuinpaikka</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="p">...</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Tämä on sinänsä toimiva tapa, mutta tässä voi tulla ongelmaksi, että profiilissa voi olla paljon vaihtelevaa tietoa, jolloin tauluun <code class="language-html highlighter-rouge">Kayttajat</code> tulee suuri määrä sarakkeita. Tämän vuoksi teemme toisenlaisen ratkaisun ja luomme uuden taulun <code class="language-html highlighter-rouge">KayttajanTiedot</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">KayttajanTiedot</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">kayttaja_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span><span class="p">,</span>
    <span class="n">avain</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">arvo</span> <span class="nb">TEXT</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Nyt käyttäjän tietoja voidaan lisätä tähän tapaan:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">KayttajanTiedot</span> <span class="p">(</span><span class="n">kayttaja_id</span><span class="p">,</span> <span class="n">avain</span> <span class="nb">TEXT</span><span class="p">,</span> <span class="n">arvo</span> <span class="nb">TEXT</span><span class="p">)</span>
            <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">'nimi'</span><span class="p">,</span><span class="s1">'Maija Virtanen'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">KayttajanTiedot</span> <span class="p">(</span><span class="n">kayttaja_id</span><span class="p">,</span> <span class="n">avain</span> <span class="nb">TEXT</span><span class="p">,</span> <span class="n">arvo</span> <span class="nb">TEXT</span><span class="p">)</span>
            <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">'syntymapaiva'</span><span class="p">,</span><span class="s1">'2000-01-01'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">KayttajanTiedot</span> <span class="p">(</span><span class="n">kayttaja_id</span><span class="p">,</span> <span class="n">avain</span> <span class="nb">TEXT</span><span class="p">,</span> <span class="n">arvo</span> <span class="nb">TEXT</span><span class="p">)</span>
            <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">'asuinpaikka'</span><span class="p">,</span><span class="s1">'Helsinki'</span><span class="p">);</span>
</code></pre></div></div>

<p>Tämän ratkaisu ansiosta tietokannan rakenteessa ei tarvitse määritellä, mitä kaikkea tietoa profiiliin mahdollisesti voidaan tallentaa, mutta tiedot on tallettu kuitenkin erillisinä.</p>

<h4 id="ystävyyssuhteet">Ystävyyssuhteet</h4>

<ul>
  <li>Käyttäjä voi ystävystyä muiden palvelun käyttäjien kanssa.</li>
</ul>

<p>Tietokannassa täytyy olla tieto siitä, ketkä käyttäjät ovat ystäviä keskenään. Tämä onnistuu luomalla uusi taulu ystävyyssuhteita varten:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Ystavat</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">kayttaja1_id</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span><span class="p">,</span>
    <span class="n">kayttaja2_id</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Tämä taulu viittaa kahdesti tauluun <code class="language-html highlighter-rouge">Kayttajat</code>, koska ystävyyssuhde liittyy kahteen käyttäjään.</p>

<h4 id="valokuvien-lisääminen">Valokuvien lisääminen</h4>

<ul>
  <li>Käyttäjä voi lähettää palveluun valokuvia ja valita yhden niistä profiilikuvaksi.</li>
</ul>

<p>Valokuvien lisääminen voidaan toteuttaa samaan tapaan kuin päivitysten lisääminen:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Valokuvat</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">kayttaja_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span><span class="p">,</span>
    <span class="n">kuva</span> <span class="k">DATA</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Tässä ei oteta tarkemmin kantaa siihen, miten valokuva tallennetaan palvelimelle, vaan sarakkeen tyyppinä on vain <code class="language-html highlighter-rouge">DATA</code>.</p>

<p>Entä kuinka toteutamme profiilikuvan valitsemisen? Tähän on monia mahdollisia tapoja: voisimme lisätä tiedon asiasta tauluun <code class="language-html highlighter-rouge">Kayttajat</code> tai <code class="language-html highlighter-rouge">Valokuvat</code> tai luoda uuden taulun, joka kertoo, mikä kuva on kenenkin käyttäjän profiilikuva.</p>

<p>Koska käyttäjällä on enintään yksi profiilikuva, uudelle taululle ei ole oikeastaan tarvetta. Päädymme lisäämään tiedon tauluun <code class="language-html highlighter-rouge">Kayttajat</code>, koska jos tieto olisi taulussa <code class="language-html highlighter-rouge">Valokuvat</code>, pitäisi jotenkin erikseen varmistaa, että usea kuva ei ole samaan aikaan profiilikuvana. Tämän seurauksena taulu <code class="language-html highlighter-rouge">Kayttajat</code> muuttuu näin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Kayttajat</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">tunnus</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">salasana</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">kuva_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Valokuvat</span>
<span class="p">);</span>
</code></pre></div></div>

<h4 id="tykkäykset-ja-kommentit">Tykkäykset ja kommentit</h4>

<ul>
  <li>Käyttäjät voivat tykätä ja kommentoida toistensa päivityksiä ja kuvia.</li>
</ul>

<p>Tämän toiminnon toteuttamiseen on monia mahdollisuuksia. Seuraavassa ratkaisussa taulu <code class="language-html highlighter-rouge">Tykkaykset</code> sisältää kaikki tykkäykset ja taulu <code class="language-html highlighter-rouge">Kommentit</code> sisältää kaikki kommentit.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Tykkaykset</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">kayttaja_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span><span class="p">,</span>
    <span class="n">paivitys_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Paivitykset</span><span class="p">,</span>
    <span class="n">kuva_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Valokuvat</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Kommentit</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">kayttaja_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span><span class="p">,</span>
    <span class="n">paivitys_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Paivitykset</span><span class="p">,</span>
    <span class="n">kuva_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Valokuvat</span><span class="p">,</span>
    <span class="n">viesti</span> <span class="nb">TEXT</span>
    <span class="n">aika</span> <span class="nb">DATETIME</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Ideana on, että jos tykkäys tai kommentti liittyy päivitykseen, niin sarake <code class="language-html highlighter-rouge">paivitys_id</code> osoittaa päivitykseen ja sarake <code class="language-html highlighter-rouge">kuva_id</code> on <code class="language-html highlighter-rouge">NULL</code>. Vastaavasti jos tykkäys tai kommentti liittyy kuvaan, sarake <code class="language-html highlighter-rouge">paivitys_id</code> on <code class="language-html highlighter-rouge">NULL</code> ja sarake <code class="language-html highlighter-rouge">kuva_id</code> osoittaa kuvaan.</p>

<p>Vaihtoehtoinen ratkaisu olisi luoda kahden taulun sijasta neljä taulua niin, että päivitysten ja kuvien tiedot ovat omissa tauluissaan. Tämän etuna olisi, että riveillä ei ole <code class="language-html highlighter-rouge">NULL</code>-arvoja, mutta tämä toisaalta mutkistaisi tietokannan rakennetta.</p>

<h4 id="yksityisviestit">Yksityisviestit</h4>

<ul>
  <li>Käyttäjät voivat lähettää toisilleen yksityisviestejä.</li>
</ul>

<p>Tämän toiminnon saamme toteutettua samalla tavalla kuin ystävystymisen lisäämällä uuden taulun, joka viittaa kahteen käyttäjään.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Viestit</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">kayttaja1_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span><span class="p">,</span>
    <span class="n">kayttaja2_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span><span class="p">,</span>
    <span class="n">viesti</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">aika</span> <span class="nb">DATETIME</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Tässä tulkintana on, että käyttäjä 1 on viestin lähettäjä ja käyttäjä 2 on viestin vastaanottaja.</p>

<h4 id="ylläpitäjät">Ylläpitäjät</h4>

<ul>
  <li>Palvelussa on myös ylläpitäjiä, joilla on enemmän oikeuksia kuin muilla käyttäjillä.</li>
</ul>

<p>Tämän toiminnon toteuttamiseen on periaatteessa kaksi vaihtoehtoa: kaikki käyttäjät (myös ylläpitäjät) ovat samassa taulussa tai ylläpitäjät ovat erillisessä taulussa.</p>

<p>Kokemus on osoittanut, että parempi ratkaisu on tallentaa kaikki käyttäjät samaan tauluun, koska käyttäjillä on kuitenkin yhteisiä toimintoja, joiden toteuttaminen olisi hankalaa, jos tietoa pitäisi etsiä eri tauluista riippuen käyttäjän asemasta. Käyttäjät voidaan tallentaa samaan tauluun, kun tauluun lisätään sarake, joka ilmaisee käyttäjän roolin.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Kayttajat</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">tunnus</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">salasana</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">kuva_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Valokuvat</span><span class="p">,</span>
    <span class="n">yllapitaja</span> <span class="nb">BOOLEAN</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="tietokannan-kuvaaminen">Tietokannan kuvaaminen</h3>

<p>Tietokannan rakenteen kuvaamiseen on kaksi tavallista tapaa: graafinen tietokantakaavio, joka esittää taulujen suhteet, sekä SQL-skeema, jossa on taulujen luontikomennot.</p>

<h4 id="tietokantakaavio">Tietokantakaavio</h4>

<p>Tietokantakaavio on tietokannan graafinen esitys, jossa jokainen tietokannan taulu on laatikko, joka sisältää taulun nimen ja sarakkeet listana. Rivien viittaukset toisiinsa esitetään laatikoiden välisinä yhteyksinä.</p>

<p>Tietokantakaavion piirtämiseen on monia vähän erilaisia tapoja. Seuraava kaavio on luotu netissä olevalla työkalulla <a href="https://dbdiagram.io/">dbdiagram.io</a>:</p>

<p><img src="/syksy-2023/assets/kaavio.png" /></p>

<p>Tässä merkki <code class="language-html highlighter-rouge">1</code> tarkoittaa, että sarakkeessa on eri arvo joka rivillä, ja merkki <code class="language-html highlighter-rouge">*</code> puolestaan tarkoittaa, että sarakkeessa voi olla sama arvo usealla rivillä.</p>

<h4 id="sql-skeema">SQL-skeema</h4>

<p>SQL-skeema sisältää <code class="language-html highlighter-rouge">CREATE TABLE</code> -komennot, joiden avulla tietokanta voidaan muodostaa. Seuraava SQL-skeema vastaa tietokantaamme:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Kayttajat</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">tunnus</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">salasana</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">kuva_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Valokuvat</span><span class="p">,</span>
    <span class="n">yllapitaja</span> <span class="nb">BOOLEAN</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Paivitykset</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">kayttaja_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span><span class="p">,</span>
    <span class="n">viesti</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">aika</span> <span class="nb">DATETIME</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">KayttajanTiedot</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">kayttaja_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span><span class="p">,</span>
    <span class="n">avain</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">arvo</span> <span class="nb">TEXT</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Ystavat</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">kayttaja1_id</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span><span class="p">,</span>
    <span class="n">kayttaja2_id</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Valokuvat</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">kayttaja_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span><span class="p">,</span>
    <span class="n">kuva</span> <span class="k">DATA</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Tykkaykset</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">kayttaja_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span><span class="p">,</span>
    <span class="n">paivitys_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Paivitykset</span><span class="p">,</span>
    <span class="n">kuva_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Valokuvat</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Kommentit</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">kayttaja_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span><span class="p">,</span>
    <span class="n">paivitys_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Paivitykset</span><span class="p">,</span>
    <span class="n">kuva_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Valokuvat</span><span class="p">,</span>
    <span class="n">viesti</span> <span class="nb">TEXT</span>
    <span class="n">aika</span> <span class="nb">DATETIME</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Viestit</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">kayttaja1_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span><span class="p">,</span>
    <span class="n">kayttaja2_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Kayttajat</span><span class="p">,</span>
    <span class="n">viesti</span> <span class="nb">TEXT</span><span class="p">,</span>
    <span class="n">aika</span> <span class="nb">DATETIME</span>
<span class="p">);</span>
</code></pre></div></div>

<!--
Table Kayttajat as K {
  id INTEGER [pk]
  tunnus TEXT
  salasana TEXT
  kuva_id INTEGER
  yllapitaja BOOLEAN
}

Ref: K.kuva_id > V.id

Table Paivitykset as P {
  id INTEGER [pk]
  kayttaja_id INTEGER
  viesti TEXT
  aika DATETIME
}

Ref: P.kayttaja_id > K.id

Table KayttajanTiedot as KT {
  id INTEGER [pk]
  kayttaja_id INTEGER
  avain TEXT
  arvo TEXT
}

Ref: KT.kayttaja_id > K.id

Table Ystavat as Y {
  id INTEGER [pk]
  kayttaja1_id INTEGER
  kayttaja2_id INTEGER
}

Ref: Y.kayttaja1_id > K.id
Ref: Y.kayttaja2_id > K.id

Table Valokuvat as V {
  id INTEGER [pk]
  kayttaja_id INTEGER
  kuva DATA
}

Ref: V.kayttaja_id > K.id

Table Tykkaykset as T{
  id INTEGER [pk]
  kayttaja_id INTEGER
  paivitys_id INTEGER
  kuva_id INTEGER
}

Ref: T.kayttaja_id > K.id
Ref: T.paivitys_id > P.id
Ref: T.kuva_id > V.id

Table Kommentit as Z {
  id INTEGER [pk]
  kayttaja_id INTEGER
  paivitys_id INTEGER
  kuva_id INTEGER
  viesti TEXT
  aika DATETIME
}

Ref: Z.kayttaja_id > K.id
Ref: Z.paivitys_id > P.id
Ref: Z.kuva_id > V.id

Table Viestit as W {
  id INTEGER [pk]
  kayttaja1_id INTEGER
  kayttaja2_id INTEGER
  viesti TEXT
  aika DATETIME
}

Ref: W.kayttaja1_id > K.id
Ref: W.kayttaja2_id > K.id
-->

<h1 id="7-tietokannan-ominaisuudet">7. Tietokannan ominaisuudet</h1>

<h2 id="tiedon-eheys">Tiedon eheys</h2>

<p>Tiedon eheys viittaa siihen, että tietokannassa oleva tieto on paikkansa pitävää ja ristiriidatonta. Päävastuu tiedon laadusta on toki käyttäjällä tai sovelluksella, joka muuttaa tietokantaa, mutta myös tietokannan suunnittelija voi vaikuttaa asiaan lisäämällä tauluihin ehtoja, jotka tarkkailevat tietokantaan syötettävää tietoa.</p>

<h3 id="sarakkeiden-ehdot">Sarakkeiden ehdot</h3>

<p>Voimme määrittää taulun luonnin yhteydessä sarakkeisiin liittyviä ehtoja, joita tietokantajärjestelmä valvoo tiedon lisäämisen ja muuttamisen yhteydessä. Näillä ehdoilla voi ohjata sitä, millaista tietoa tietokantaan ilmestyy. Tyypillisiä ehtoja ovat seuraavat:</p>

<h4 id="unique">UNIQUE</h4>

<p>Ehto <code class="language-html highlighter-rouge">UNIQUE</code> tarkoittaa, että kyseisessä sarakkeessa tulee olla eri arvo joka rivillä. Esimerkiksi seuraavassa taulussa vaatimuksena on, että joka tuotteella on eri nimi:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="n">nimi</span> <span class="nb">TEXT</span> <span class="k">UNIQUE</span><span class="p">,</span> <span class="n">hinta</span> <span class="nb">INTEGER</span><span class="p">);</span>
</code></pre></div></div>

<p>Ehto <code class="language-html highlighter-rouge">UNIQUE</code> voi kohdistua myös useampaan sarakkeeseen, jolloin se merkitään erikseen sarakkeiden jälkeen:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="n">nimi</span> <span class="nb">TEXT</span><span class="p">,</span> <span class="n">hinta</span> <span class="nb">INTEGER</span><span class="p">,</span> <span class="k">UNIQUE</span><span class="p">(</span><span class="n">nimi</span><span class="p">,</span><span class="n">hinta</span><span class="p">));</span>
</code></pre></div></div>

<p>Tämä tarkoittaa, että taulussa ei voi olla kahta riviä, joilla on sama nimi ja sama hinta.</p>

<h4 id="not-null-ja-default">NOT NULL ja DEFAULT</h4>

<p>Ehto <code class="language-html highlighter-rouge">NOT NULL</code> tarkoittaa, että kyseisessä sarakkeessa ei saa olla arvoa <code class="language-html highlighter-rouge">NULL</code>. Esimerkiksi seuraavassa taulussa tuotteen hinta ei saa olla tyhjä:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="n">nimi</span> <span class="nb">TEXT</span><span class="p">,</span> <span class="n">hinta</span> <span class="nb">INTEGER</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">);</span>
</code></pre></div></div>

<p>Tähän liittyy myös määre <code class="language-html highlighter-rouge">DEFAULT</code>, jonka seurauksena sarake saa tietyn oletusarvon, jos sille ei anneta arvoa rivin lisäämisessä. Esimerkiksi voimme määrittää oletusarvon 0 näin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="n">nimi</span> <span class="nb">TEXT</span><span class="p">,</span> <span class="n">hinta</span> <span class="nb">INTEGER</span> <span class="k">DEFAULT</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="check">CHECK</h4>

<p>Yleisempi tapa luoda ehto on käyttää avainsanaa <code class="language-html highlighter-rouge">CHECK</code>, jonka jälkeen voi kirjoittaa minkä tahansa ehtolausekkeen. Esimerkiksi seuraava komento luo taulun tuotteista, jossa rivin ehtona on <code class="language-html highlighter-rouge">hinta &gt;= 0</code> eli hinta ei saa olla negatiivinen:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="n">nimi</span> <span class="nb">TEXT</span><span class="p">,</span> <span class="n">hinta</span> <span class="nb">INTEGER</span><span class="p">,</span> <span class="k">CHECK</span> <span class="p">(</span><span class="n">hinta</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">));</span>
</code></pre></div></div>

<h3 id="ehtojen-valvonta">Ehtojen valvonta</h3>

<p>Ehtojen hyötynä on, että tietokantajärjestelmä valvoo niitä ja kieltäytyy tekemästä lisäystä tai muutosta, joka rikkoisi ehdon. Seuraavassa on esimerkki tästä SQLitessä:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>CREATE TABLE Tuotteet (id INTEGER PRIMARY KEY, nimi TEXT, hinta INTEGER, CHECK (hinta &gt;= 0));
<span class="p">sqlite&gt; </span>INSERT INTO Tuotteet(nimi,hinta) VALUES ('retiisi',4);
<span class="p">sqlite&gt; </span>INSERT INTO Tuotteet(nimi,hinta) VALUES ('selleri',7);
<span class="p">sqlite&gt; </span>INSERT INTO Tuotteet(nimi,hinta) VALUES ('nauris',-2);
Error: CHECK constraint failed: Tuotteet
<span class="p">sqlite&gt; </span>SELECT * FROM Tuotteet;
1|retiisi|4
2|selleri|7
<span class="p">sqlite&gt; </span>UPDATE Tuotteet SET hinta=-2 WHERE id=2;
Error: CHECK constraint failed: Tuotteet
</code></pre></div></div>

<p>Kun koetamme lisätä tauluun <code class="language-html highlighter-rouge">Tuotteet</code> rivin, jossa hinta on negatiivinen, tämä rikkoo ehdon <code class="language-html highlighter-rouge">hinta &gt;= 0</code> ja SQLite ei salli rivin lisäämistä vaan antaa virheen <code class="language-html highlighter-rouge">CHECK constraint failed: Tuotteet</code>. Samalla tavalla käy, jos koetamme muuttaa olemassa olevan rivin sarakkeen hinnan negatiiviseksi jälkeenpäin.</p>

<h3 id="ehdot-ohjelmoinnissa">Ehdot ohjelmoinnissa</h3>

<p>Seuraava esimerkki näyttää, miten taulussa olevaa ehtoa voidaan hyödyntää ohjelmoinnissa. Haluamme, että tietokannan jokaisella tuotteella on eri nimi, minkä vuoksi sarakkeessa <code class="language-html highlighter-rouge">nimi</code> on ehtona <code class="language-html highlighter-rouge">UNIQUE</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="n">nimi</span> <span class="nb">TEXT</span> <span class="k">UNIQUE</span><span class="p">,</span> <span class="n">hinta</span> <span class="nb">INTEGER</span><span class="p">);</span>
</code></pre></div></div>

<p>Nyt tuotteen lisäämisen tietokantaan voi toteuttaa näin:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">nimi</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Anna nimi: "</span><span class="p">)</span>
<span class="n">hinta</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Anna hinta: "</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"INSERT INTO Tuotteet (nimi, hinta) VALUES (?,?)"</span><span class="p">,</span> <span class="p">[</span><span class="n">nimi</span><span class="p">,</span> <span class="n">hinta</span><span class="p">])</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Lisäys ei onnistunut"</span><span class="p">)</span>
</code></pre></div></div>

<p>Tässä tapauksessa komento <code class="language-html highlighter-rouge">INSERT</code> epäonnistuu siinä tapauksessa, että taulussa on jo valmiina samanniminen tuote. Niinpä koodi voi <em>yrittää</em> lisätä tuotetta tutkimatta, onko tuote jo valmiina taulussa, ja jos tästä tulee virhe, tiedetään, että tuote oli valmiina.</p>

<p>Tämä on selkeästi parempi toteutus kuin tutkia koodissa ennen lisäämistä <code class="language-html highlighter-rouge">SELECT</code>-kyselyllä, onko tuotetta jo tietokannassa, koska <code class="language-html highlighter-rouge">UNIQUE</code>-ehdon avulla tietokanta pitää luotettavasti huolen asiasta ja koodiakin tarvitaan vähemmän. Jos taulussa ei olisi <code class="language-html highlighter-rouge">UNIQUE</code>-ehtoa ja sovellus suorittaisi komennot <code class="language-html highlighter-rouge">SELECT</code> ja <code class="language-html highlighter-rouge">INSERT</code>, olisi mahdollista, että toinen tietokannan käyttäjä ehtisi lisätä välissä saman tuotteen tauluun, jolloin taulussa olisikin kaksi tuotetta samalla nimellä. Kuitenkaan <code class="language-html highlighter-rouge">UNIQUE</code>-ehdon kanssa näin ei voi tapahtua mitenkään.</p>

<h3 id="viittausten-ehdot">Viittausten ehdot</h3>

<p>Voimme liittää myös tauluihin ehtoja, jotka pitävät huolen siitä, että tauluissa olevat viittaukset viittaavat todellisiin riveihin. Tämä tapahtuu luomalla <em>viiteavain</em> (<em>foreign key</em>), joka ilmaisee, mihin taulussa oleva rivi viittaa.</p>

<p>Tarkastellaan esimerkkinä seuraavia tauluja:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Opettajat</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="n">nimi</span> <span class="nb">TEXT</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Kurssit</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="n">nimi</span> <span class="nb">TEXT</span><span class="p">,</span> <span class="n">opettaja_id</span> <span class="nb">INTEGER</span><span class="p">);</span>
</code></pre></div></div>

<p>Tässä tarkoituksena on, että taulun <code class="language-html highlighter-rouge">Kurssit</code> sarake <code class="language-html highlighter-rouge">opettaja_id</code> viittaa taulun <code class="language-html highlighter-rouge">Opettajat</code> sarakkeeseen <code class="language-html highlighter-rouge">id</code>, mutta tietokannan käyttäjä voi antaa sarakkeen <code class="language-html highlighter-rouge">opettaja_id</code> arvoksi mitä tahansa (esim. luvun 123), jolloin tietokannan sisältö muuttuu epämääräiseksi.</p>

<p>Voimme parantaa tilannetta kertomalla taulun <code class="language-html highlighter-rouge">Kurssit</code> luonnissa, että sarake <code class="language-html highlighter-rouge">opettaja_id</code> on viiteavain tauluun <code class="language-html highlighter-rouge">Opettajat</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Kurssit</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="n">nimi</span> <span class="nb">TEXT</span><span class="p">,</span> <span class="n">opettaja_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Opettajat</span><span class="p">);</span>
</code></pre></div></div>

<p>Tämän jälkeen voimme luottaa siihen, että taulussa <code class="language-html highlighter-rouge">Kurssit</code> sarakkeen <code class="language-html highlighter-rouge">opettaja_id</code> arvot
viittaavat todellisiin riveihin taulussa <code class="language-html highlighter-rouge">Opettajat</code>.</p>

<p>Huomaa, että historiallisista syistä SQLite <em>ei</em> oletuksena valvo viiteavainten ehtoja, vaan meidän tulee ensin suorittaa seuraava komento:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>PRAGMA foreign_keys = ON;
</code></pre></div></div>

<p>Tämä on SQLiten erikoisuus, ja muissa tietokannoissa viiteavaimia valvotaan aina.</p>

<p>Tässä on esimerkki viiteavaimen käyttämisestä:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>PRAGMA foreign_keys = ON;
<span class="p">sqlite&gt; </span>CREATE TABLE Opettajat (id INTEGER PRIMARY KEY, nimi TEXT);
<span class="p">sqlite&gt; </span>CREATE TABLE Kurssit (id INTEGER PRIMARY KEY, nimi TEXT, opettaja_id INTEGER
   ...&gt;                       REFERENCES Opettajat);
<span class="p">sqlite&gt; </span>INSERT INTO Opettajat (nimi) VALUES ('Kaila');
<span class="p">sqlite&gt; </span>INSERT INTO Opettajat (nimi) VALUES ('Kivinen');
<span class="p">sqlite&gt; </span>SELECT * FROM Opettajat;
1|Kaila
2|Kivinen
<span class="p">sqlite&gt; </span>INSERT INTO Kurssit (nimi, opettaja_id) VALUES ('Laskennan mallit',2);
<span class="p">sqlite&gt; </span>INSERT INTO Kurssit (nimi, opettaja_id) VALUES ('Ohjelmoinnin perusteet',123);
Error: FOREIGN KEY constraint failed   
</code></pre></div></div>

<p>Taulussa <code class="language-html highlighter-rouge">Opettaja</code> on kaksi opettajaa, joiden id-numerot ovat 1 ja 2. Niinpä kun koetamme lisätä tauluun <code class="language-html highlighter-rouge">Kurssit</code> rivin, jossa <code class="language-html highlighter-rouge">opettaja_id</code> on 123, SQLite ei salli tätä vaan saamme virheilmoituksen <code class="language-html highlighter-rouge">FOREIGN KEY constraint failed</code>.</p>

<h3 id="viittaukset-ja-poistot">Viittaukset ja poistot</h3>

<p>Viittausten ehtoihin liittyy tavallisia sarakkeiden ehtoja mutkikkaampia tilanteita, koska viittaukset ovat kahden taulun välisiä. Erityisesti mitä tapahtuu, jos taulusta yritetään poistaa rivi, johon viitataan toisen taulun rivillä?</p>

<p>Yleensä oletuksena tietokannoissa riviä ei voi poistaa, jos siihen on viittaus muualta. Esimerkiksi jos koetamme äskeisen esimerkin päätteeksi poistaa taulusta <code class="language-html highlighter-rouge">Opettajat</code> rivin 2, tämä ei onnistu, koska siihen viitataan taulussa <code class="language-html highlighter-rouge">Kurssit</code>:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>DELETE FROM Opettajat WHERE id=2;
Error: FOREIGN KEY constraint failed
</code></pre></div></div>

<p>Halutessamme voimme kuitenkin määrittää taulun luonnissa tarkemmin, mitä tapahtuu tässä tilanteessa. Esimerkiksi yksi vaihtoehto on <code class="language-html highlighter-rouge">ON DELETE CASCADE</code>, mikä tarkoittaa, että rivin poistuessa myös siihen viittaavat rivit poistetaan. Saamme tämän aikaan näin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Kurssit</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="n">nimi</span> <span class="nb">TEXT</span><span class="p">,</span>
                      <span class="n">opettaja_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">Opettajat</span> <span class="k">ON</span> <span class="k">DELETE</span> <span class="k">CASCADE</span><span class="p">);</span>
</code></pre></div></div>

<p>Nyt jos tietokannasta poistetaan opettaja, niin samalla poistetaan automaattisesti kaikki kurssit, joita hän opettaa. Tämä voi kuitenkin olla kyseenalainen vaihtoehto, koska tämän seurauksena tietokannan tauluista voi kadota yllättäen tietoa.</p>

<p>Mahdollisia vaihtoehtoja <code class="language-html highlighter-rouge">ON DELETE</code> -osassa ovat:</p>

<ul>
  <li><code class="language-html highlighter-rouge">NO ACTION</code>: “älä tee mitään” (oletus)</li>
  <li><code class="language-html highlighter-rouge">RESTRICT</code>: estä poistaminen</li>
  <li><code class="language-html highlighter-rouge">CASCADE</code>: poista myös viittaavat rivit</li>
  <li><code class="language-html highlighter-rouge">SET NULL</code>: muuta viittaukset arvoksi <code class="language-html highlighter-rouge">NULL</code></li>
  <li><code class="language-html highlighter-rouge">SET DEFAULT</code>: muuta viittaukset oletusarvoksi</li>
</ul>

<p>Hämmentävä seikka on, että myös oletusvaihtoehto <code class="language-html highlighter-rouge">NO ACTION</code> estää rivin poistamisen, vaikka nimestä voisi päätellä muuta. Vaihtoehdot <code class="language-html highlighter-rouge">NO ACTION</code> ja <code class="language-html highlighter-rouge">RESTRICT</code> toimivat käytännössä lähes samalla tavalla, mutta tietokannasta riippuen niiden toiminnassa voi olla eroja joissain erikoistilanteissa.</p>

<h2 id="transaktiot">Transaktiot</h2>

<p><em>Transaktio</em> on joukko peräkkäisiä SQL-komentoja, jotka tietokantajärjestelmä lupaa suorittaa yhtenä kokonaisuutena. Tietokannan käyttäjä voi luottaa siihen, että joko (1) kaikki komennot suoritetaan ja muutokset jäävät pysyvästi tietokantaan tai (2) transaktio keskeytyy eivätkä komennot aiheuta mitään muutoksia tietokantaan.</p>

<p>Transaktioiden yhteydessä esiintyy usein ihanteena kirjainyhdistelmä <em>ACID</em>, joka tulee seuraavista sanoista:</p>

<ul>
  <li><em>Atomicity</em>: Transaktiossa olevat komennot suoritetaan
yhtenä kokonaisuutena.</li>
  <li><em>Consistency</em>: Transaktio säilyttää tietokannan sisällön eheänä.</li>
  <li><em>Isolation</em>: Transaktiot suoritetaan eristyksessä toisistaan.</li>
  <li><em>Durability</em>: Loppuun viedyn transaktion tekemät muutokset jäävät pysyviksi.</li>
</ul>

<h3 id="transaktion-vaiheet">Transaktion vaiheet</h3>

<p>Itse asiassa transaktio on hyvin arkipäiväinen asia tietokannan käyttämisessä, sillä oletuksena <em>jokainen</em> suoritettava SQL-komento on oma transaktionsa. Tarkastellaan esimerkiksi seuraavaa komentoa, joka kasvattaa jokaisen tuotteen hintaa yhdellä:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">UPDATE</span> <span class="n">Tuotteet</span> <span class="k">SET</span> <span class="n">hinta</span><span class="o">=</span><span class="n">hinta</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>Koska komento suoritetaan transaktiona, voimme luottaa siihen, että joko jokaisen tuotteen hinta todella kasvaa yhdellä tai sitten minkään tuotteen hinta ei muutu. Jälkimmäinen voi tapahtua esimerkiksi silloin, kun sähköt katkeavat kesken päivityksen. Siinäkään tapauksessa ei siis voi käydä niin, että vain <em>osa</em> hinnoista muuttuu.</p>

<p>Usein kuitenkin sana transaktio viittaa erityisesti siihen, että kokonaisuuteen kuuluu useampi SQL-komento. Tällöin annamme ensin komennon <code class="language-html highlighter-rouge">BEGIN</code>, joka aloittaa transaktion, sitten kaikki transaktioon kuuluvat komennot tavalliseen tapaan ja lopuksi komennon <code class="language-html highlighter-rouge">COMMIT</code>, joka päättää transaktion.</p>

<p>Klassinen esimerkki transaktiosta on tilanne, jossa pankissa siirretään rahaa tililtä toiselle. Esimerkiksi seuraava transaktio siirtää 100 euroa Maijan tililtä Uolevin tilille:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">BEGIN</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">Tilit</span> <span class="k">SET</span> <span class="n">saldo</span><span class="o">=</span><span class="n">saldo</span><span class="o">-</span><span class="mi">100</span> <span class="k">WHERE</span> <span class="n">omistaja</span><span class="o">=</span><span class="s1">'Maija'</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">Tilit</span> <span class="k">SET</span> <span class="n">saldo</span><span class="o">=</span><span class="n">saldo</span><span class="o">+</span><span class="mi">100</span> <span class="k">WHERE</span> <span class="n">omistaja</span><span class="o">=</span><span class="s1">'Uolevi'</span><span class="p">;</span>
<span class="k">COMMIT</span><span class="p">;</span>
</code></pre></div></div>

<p>Transaktion ideana on, että mitään pysyvää muutosta ei tapahdu ennen komentoa <code class="language-html highlighter-rouge">COMMIT</code>. Niinpä yllä olevassa esimerkissä ei ole mahdollista, että Maija menettäisi 100 euroa mutta Uolevi ei saisi mitään. Joko kummankin tilin saldo muuttuu ja rahat siirtyvät onnistuneesti tai molemmat saldot säilyvät entisellään.</p>

<p>Jos transaktio keskeytyy jostain syystä ennen komentoa <code class="language-html highlighter-rouge">COMMIT</code>, kaikki transaktiossa tehdyt muutokset peruuntuvat. Yksi syy transaktion keskeytymiseen on jokin häiriö tietokoneen toiminnassa (kuten sähköjen katkeaminen), mutta voimme myös itse halutessamme keskeyttää transaktion antamalla komennon <code class="language-html highlighter-rouge">ROLLBACK</code>.</p>

<h3 id="transaktioiden-kokeilu">Transaktioiden kokeilu</h3>

<p>Hyvä tapa saada ymmärrystä transaktioista on kokeilla käytännössä, miten ne toimivat. Tässä on esimerkkinä yksi keskustelu SQLiten kanssa:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>CREATE TABLE Tilit (id INTEGER PRIMARY KEY, omistaja TEXT, saldo INTEGER);
<span class="p">sqlite&gt; </span>INSERT INTO Tilit (omistaja,saldo) VALUES ('Uolevi',350);
<span class="p">sqlite&gt; </span>INSERT INTO Tilit (omistaja,saldo) VALUES ('Maija',600);
<span class="p">sqlite&gt; </span>SELECT * FROM Tilit;
1|Uolevi|350
2|Maija|600
<span class="p">sqlite&gt; </span>BEGIN;
<span class="p">sqlite&gt; </span>UPDATE Tilit SET saldo=saldo-100 WHERE omistaja='Maija';
<span class="p">sqlite&gt; </span>SELECT * FROM Tilit;
1|Uolevi|350
2|Maija|500
<span class="p">sqlite&gt; </span>ROLLBACK;
<span class="p">sqlite&gt; </span>SELECT * FROM Tilit;
1|Uolevi|350
2|Maija|600
<span class="p">sqlite&gt; </span>BEGIN;
<span class="p">sqlite&gt; </span>UPDATE Tilit SET saldo=saldo-100 WHERE omistaja='Maija';
<span class="p">sqlite&gt; </span>UPDATE Tilit SET saldo=saldo+100 WHERE omistaja='Uolevi';
<span class="p">sqlite&gt; </span>COMMIT;
<span class="p">sqlite&gt; </span>SELECT * FROM Tilit;
1|Uolevi|450
2|Maija|500
</code></pre></div></div>

<p>Alkutilanteessa Uolevin tilillä on 350 euroa ja Maijan tilillä on 600 euroa. Ensimmäisessä transaktiossa poistamme ensin Maijan tililtä 100 euroa, mutta sen jälkeen tulemme toisiin ajatuksiin ja keskeytämme transaktion. Niinpä transaktiossa tehty muutos peruuntuu ja tilien saldot ovat samat kuin alkutilanteessa. Toisessa transaktiossa viemme kuitenkin transaktion loppuun, minkä seurauksena Uolevin tilillä on 450 euroa ja Maijan tilillä on 500 euroa.</p>

<p>Huomaa, että transaktion sisällä muutokset kyllä näkyvät, vaikka niitä ei olisi tehty vielä pysyvästi tietokantaan. Esimerkiksi ensimmäisen transaktion <code class="language-html highlighter-rouge">SELECT</code>-kysely antaa Maijan tilin saldoksi 500 euroa, koska edellinen <code class="language-html highlighter-rouge">UPDATE</code>-komento muutti saldoa.</p>

<h3 id="transaktiot-ohjelmoinnissa">Transaktiot ohjelmoinnissa</h3>

<p>Transaktiokomentoja (<code class="language-html highlighter-rouge">BEGIN</code>, <code class="language-html highlighter-rouge">COMMIT</code>, jne.) voi suorittaa ohjelmoinnissa samaan tapaan kuin muitakin SQL-komentoja. Esimerkiksi seuraava koodi lisää tauluun <code class="language-html highlighter-rouge">Tuotteet</code> tuhat riviä for-silmukassa yhden transaktion sisällä:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"BEGIN"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1000</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"INSERT INTO Tuotteet (nimi, hinta) VALUES (?,?)"</span><span class="p">,</span> <span class="p">[</span><span class="s">"tuote"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">db</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"COMMIT"</span><span class="p">)</span>
</code></pre></div></div>

<p>Koska koodi on transaktion sisällä, koodi joko lisää kaikki rivit tietokantaan tai ei yhtään riviä, jos transaktio epäonnistuu jostain syystä.</p>

<p>Tässä tapauksessa transaktion sivuvaikutuksena on myös, että koodi toimii nopeammin, koska jokaista riviä ei lisätä erillisen transaktion sisällä vaan lisäys tapahtuu kokonaisuutena. Tämä auttaa tietokantaa toteuttamaan rivien lisääminen tehokkaammin.</p>

<h3 id="rinnakkaiset-transaktiot">Rinnakkaiset transaktiot</h3>

<p>Lisämaustetta transaktioiden käsittelyyn tuo se, että tietokannalla voi olla useita käyttäjiä,
joilla on meneillään samanaikaisia transaktioita. Missä määrin eri käyttäjien transaktiot tulisi eristää toisistaan?</p>

<p>Tämä on kysymys, johon ei ole yhtä oikeaa vastausta, vaan vastaus riippuu käyttötilanteesta ja myös tietokannan ominaisuuksista. Tavallaan paras ratkaisu olisi eristää transaktiot täydellisesti toisistaan, mutta toisaalta tämä voi haitata tietokannan käyttämistä.</p>

<p>SQL-standardi määrittelee transaktioiden eristystasot seuraavasti:</p>

<h4 id="taso-1-read-uncommitted">Taso 1 (read uncommitted)</h4>

<p>On sallittua, että transaktio pystyy näkemään toisen transaktion tekemän muutoksen, vaikka toista transaktiota ei ole viety loppuun.</p>

<h4 id="taso-2-read-committed">Taso 2 (read committed)</h4>

<p>Toisin kuin tasolla 1, transaktio saa nähdä toisen transaktion tekemän muutoksen vain, jos toinen transaktio on viety loppuun.</p>

<h4 id="taso-3-repeatable-read">Taso 3 (repeatable read)</h4>

<p>Tason 2 vaatimus ja lisäksi jos transaktion aikana luetaan saman rivin sisältö useita kertoja,
joka kerralla saadaan sama sisältö.</p>

<h4 id="taso-4-serializable">Taso 4 (serializable)</h4>

<p>Transaktiot ovat täysin eristettyjä ja komennot käyttäytyvät samoin kuin jos transaktiot olisi suoritettu peräkkäin yksi kerrallaan jossain järjestyksessä.</p>

<h3 id="esimerkki-10">Esimerkki</h3>

<p>Tarkastellaan tilannetta, jossa tuotteen 1 hinta on aluksi 8 ja kaksi käyttäjää suorittaa samaan aikaan komentoja transaktioiden sisällä (käyttäjän 1 komennot ovat vasemmalla ja käyttäjän 2 komennot ovat oikealla):</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code>BEGIN;
                                         BEGIN;
                                         UPDATE Tuotteet SET hinta=5 WHERE id=1;
SELECT hinta FROM Tuotteet WHERE id=1;
                                         UPDATE Tuotteet SET hinta=7 WHERE id=1;
                                         COMMIT;
SELECT hinta FROM Tuotteet WHERE id=1;
COMMIT;
</code></pre></div></div>

<p>Tasolla 1 käyttäjä 1 voi saada kyselyistä tulokset 5 ja 7, koska käyttäjän 2 tekemät muutokset voivat tulla näkyviin heti, vaikka käyttäjän 2 transaktioita ei ole viety loppuun.</p>

<p>Tasolla 2 käyttäjä 1 voi saada kyselyistä tulokset 8 ja 7, koska ensimmäisen kyselyn kohdalla toista transaktiota ei ole viety loppuun, kun taas toisen kyselyn kohdalla se on viety loppuun.</p>

<p>Tasoilla 3 ja 4 käyttäjä 1 saa kyselyistä tulokset 8 ja 8, koska tämä on tilanne ennen transaktion alkua eikä välissä loppuun viety transaktio saa muuttaa luettua rivin sisältöä.</p>

<h3 id="transaktiot-käytännössä">Transaktiot käytännössä</h3>

<p>Transaktioiden toteutustavat ja saatavilla olevat eristystasot riippuvat käytetystä tietokantajärjestelmästä. Esimerkiksi SQLitessä ainoa mahdollinen taso on 4, kun taas
PostgreSQL toteuttaa tasot 2–4 ja oletuksena käytössä on taso 2.</p>

<p>Eristystaso 4 on tavallaan selkeästi paras, koska silloin transaktioiden muutokset eivät voi
näkyä mitenkään toisilleen. Miksi edes muut tasot ovat olemassa ja miksi esimerkiksi PostgreSQL:n oletustaso on 2?</p>

<p>Hyvän eristämisen hintana on, että se voi hidastaa tai estää transaktioiden suorittamista, koska transaktion vieminen loppuun voisi aiheuttaa ristiriitaisen tilanteen. Toisaalta monissa käytännön tilanteissa riittää mainiosti heikompikin eristys, kunhan tietokannan käyttäjä on siitä tietoinen.</p>

<p>Hyvää tietoa rinnakkaisten transaktioiden toiminnasta saa perehtymällä käytetyn tietokannan dokumentaatioon sekä testailemalla asioita itse käytännössä. Esimerkiksi voimme käynnistää itse <em>kaksi</em> SQLite-tulkkia, avata niillä saman tietokannan ja sen jälkeen kirjoittaa transaktioita sisältäviä komentoja ja tehdä havaintoja.</p>

<p>Seuraava keskustelu näyttää edellisen esimerkin tuloksen kahdessa rinnakkain käynnissä olevassa SQLite-tulkissa:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code>BEGIN;
                                         BEGIN;
                                         UPDATE Tuotteet SET hinta=5 WHERE id=1;
SELECT hinta FROM Tuotteet WHERE id=1;
8
                                         UPDATE Tuotteet SET hinta=7 WHERE id=1;
                                         COMMIT;
                                         Error: database is locked
SELECT hinta FROM Tuotteet WHERE id=1;
8
COMMIT;
</code></pre></div></div>

<p>Tästä näkee, että ensimmäinen transaktio tosiaan saa kummastakin kyselystä tuloksen 8. Toista transaktiota ei sen sijaan saada vietyä loppuun, vaan tulee virheviesti <code class="language-html highlighter-rouge">Error: database is locked</code>, koska tietokanta on lukittuna samanaikaisen transaktion takia. Eristys toimii siis hyvin, mutta toista transaktiota pitäisi yrittää viedä loppuun uudestaan.</p>

<p>Vertailun vuoksi tässä on vastaava keskustelu PostgreSQL-tulkeissa (tasolla 2):</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code>BEGIN;
                                         BEGIN;
                                         UPDATE Tuotteet SET hinta=5 WHERE id=1;
SELECT hinta FROM Tuotteet WHERE id=1;
8
                                         UPDATE Tuotteet SET hinta=7 WHERE id=1;
                                         COMMIT;
SELECT hinta FROM Tuotteet WHERE id=1;
7
COMMIT;
</code></pre></div></div>

<p>Nyt toisen transaktion muuttama arvo 7 ilmestyy ensimmäiseen transaktioon, mutta toisaalta molemmat transaktiot saadaan vietyä loppuun ongelmitta.</p>

<h3 id="miten-transaktiot-toimivat">Miten transaktiot toimivat?</h3>

<p>Transaktioiden toteuttaminen on kiehtova tekninen haaste tietokannoissa. Tavallaan transaktion tulee tehdä muutoksia tietokantaan, koska komennot voivat riippua edellisistä komennoista, mutta toisaalta mitään ei saa muuttaa pysyvästi ennen transaktion viemistä loppuun.</p>

<p>Yksi keskeinen ajatus tietokantojen taustalla on tallentaa muutoksia kahdella tavalla. Ensin kuvaus muutoksesta kirjataan <em>lokitiedostoon</em> (<em>write-ahead log</em>), jota voi ajatella luettelona suoritetuista komennoista. Vasta tämän jälkeen muutokset tehdään tietokannan varsinaisiin tietorakenteisiin. Nyt jos jälkimmäisessä vaiheessa sattuu jotain yllättävää, muutokset ovat jo tallessa lokitiedostossa ja ne voidaan suorittaa myöhemmin uudestaan.</p>

<p>Transaktioiden yhteydessä tietokantajärjestelmän täytyy myös pitää kirjaa siitä, mitkä muutokset ovat minkäkin meneillään olevan transaktion tekemiä. Käytännössä tauluihin voidaan tallentaa rivimuutoksia, jotka näkyvät vain tietyille transaktioille. Sitten jos transaktio pääsee loppuun asti, nämä muutokset liitetään taulun pysyväksi sisällöksi.</p>

<h2 id="kyselyjen-suoritus">Kyselyjen suoritus</h2>

<p>SQL-kieli on tietokannan käyttäjälle mukava kyselyjen tekemisessä, koska käyttäjän riittää kuvata, mitä tietoa hän haluaa hakea, ja tietokantajärjestelmä hoitaa loput. Niinpä tietokantajärjestelmän on tärkeää pystyä löytämään jokin tehokas tapa toteuttaa käyttäjän antama kysely ja toimittaa kyselyn tulokset käyttäjälle.</p>

<h3 id="kyselyn-suunnitelma">Kyselyn suunnitelma</h3>

<p>Monet tietokantajärjestelmät kertovat pyydettäessä suunnitelmansa, miten annettu kysely aiotaan suorittaa. Tämän avulla voimme tutkia tietokantajärjestelmän sisäistä toimintaa.</p>

<p>Tarkastellaan esimerkkinä kyselyä, joka hakee retiisin tiedot taulusta <code class="language-html highlighter-rouge">Tuotteet</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">WHERE</span> <span class="n">nimi</span><span class="o">=</span><span class="s1">'retiisi'</span><span class="p">;</span>
</code></pre></div></div>

<p>Kun laitamme SQLitessä kyselyn eteen sanan <code class="language-html highlighter-rouge">EXPLAIN</code>, saamme seuraavan tapaisen selostuksen suunnitelmasta:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>EXPLAIN SELECT * FROM Tuotteet WHERE nimi='retiisi';
addr  opcode         p1    p2    p3    p4             p5  comment      
----  -------------  ----  ----  ----  -------------  --  -------------
0     Init           0     12    0                    00  Start at 12  
1     OpenRead       0     2     0     3              00  root=2 iDb=0; Tuotteet
2     Rewind         0     10    0                    00               
3       Column         0     1     1                    00  r[1]=Tuotteet.nimi
4       Ne             2     9     1     (BINARY)       52  if r[2]!=r[1] goto 9
5       Rowid          0     3     0                    00  r[3]=rowid   
6       Copy           1     4     0                    00  r[4]=r[1]    
7       Column         0     2     5                    00  r[5]=Tuotteet.hinta
8       ResultRow      3     3     0                    00  output=r[3..5]
9     Next           0     3     0                    01               
10    Close          0     0     0                    00               
11    Halt           0     0     0                    00               
12    Transaction    0     0     1     0              01  usesStmtJournal=0
13    TableLock      0     2     0     Tuotteet       00  iDb=0 root=2 write=0
14    String8        0     2     0     retiisi        00  r[2]='retiisi'
15    Goto           0     1     0                    00 
</code></pre></div></div>

<p>SQLite muuttaa kyselyn tietokannan sisäiseksi <em>ohjelmaksi</em>, joka hakee tietoa tauluista. Tässä tapauksessa ohjelman suoritus alkaa riviltä 12, jossa alkaa transaktio, ja sitten rivillä 14 rekisteriin 2 sijoitetaan hakuehdossa oleva merkkijono “retiisi”. Tämän jälkeen suoritus siirtyy riville 1, jossa aloitetaan taulun <code class="language-html highlighter-rouge">Tuotteet</code> käsittely, ja rivit 2–9 muodostavat silmukan, joka etsii hakuehtoa vastaavat rivit taulusta.</p>

<p>Voimme myös pyytää tiiviimmän suunnitelman laittamalla kyselyn eteen sanat <code class="language-html highlighter-rouge">EXPLAIN QUERY PLAN</code>. Tällöin tulos voi olla seuraava:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>EXPLAIN QUERY PLAN SELECT * FROM Tuotteet WHERE nimi='retiisi';
0|0|0|SCAN TABLE Tuotteet
</code></pre></div></div>

<p>Tässä <code class="language-html highlighter-rouge">SCAN TABLE Tuotteet</code> tarkoittaa, että kysely käy läpi taulun <code class="language-html highlighter-rouge">Tuotteet</code> rivit.</p>

<h3 id="kyselyn-optimointi">Kyselyn optimointi</h3>

<p>Jos kyselyssä haetaan tietoa vain yhdestä taulusta, kysely on yleensä helppo suorittaa, mutta todelliset haasteet tulevat vastaan usean taulun kyselyissä. Tällöin tietokantajärjestelmän tulee osata <em>optimoida</em> kyselyn suorittamista eli muodostaa hyvä suunnitelma, jonka avulla halutut tiedot saadaan kerättyä tehokkaasti tauluista.</p>

<p>Tarkastellaan esimerkkinä seuraavaa kyselyä, joka listaa kurssien ja opettajien nimet:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">K</span><span class="p">.</span><span class="n">nimi</span><span class="p">,</span> <span class="n">O</span><span class="p">.</span><span class="n">nimi</span> <span class="k">FROM</span> <span class="n">Kurssit</span> <span class="n">K</span><span class="p">,</span> <span class="n">Opettajat</span> <span class="n">O</span> <span class="k">WHERE</span> <span class="n">K</span><span class="p">.</span><span class="n">opettaja_id</span> <span class="o">=</span> <span class="n">O</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<p>Koska kysely kohdistuu kahteen tauluun, olemme ajatelleet kyselyn toiminnan niin, että se muodostaa ensin kaikki rivien yhdistelmät tauluista <code class="language-html highlighter-rouge">Kurssit</code> ja <code class="language-html highlighter-rouge">Opettajat</code> ja valitsee sitten ne rivit, joilla pätee ehto <code class="language-html highlighter-rouge">K.opettaja_id = O.id</code>. Tämä on hyvä ajattelutapa, mutta tämä <em>ei</em> vastaa sitä, miten kunnollinen tietokantajärjestelmä toimii.</p>

<p>Ongelmana on, että tauluissa <code class="language-html highlighter-rouge">Kurssit</code> ja <code class="language-html highlighter-rouge">Opettajat</code> voi molemmissa olla suuri määrä rivejä. Esimerkiksi jos kummassakin taulussa on miljoona riviä, rivien yhdistelmiä olisi miljoona miljoonaa ja veisi valtavasti aikaa muodostaa ja käydä läpi kaikki yhdistelmät.</p>

<p>Tässä tilanteessa tietokantajärjestelmän pitääkin ymmärtää, mitä käyttäjä oikeastaan on hakemassa ja miten kyselyssä annettu ehto rajoittaa tulosrivejä. Käytännössä riittää käydä läpi kaikki taulun <code class="language-html highlighter-rouge">Kurssit</code> rivit ja etsiä jokaisen rivin kohdalla jotenkin tehokkaasti yksittäinen haluttu rivi taulusta <code class="language-html highlighter-rouge">Opettajat</code>.</p>

<p>Voimme taas pyytää SQLiteä selittämään kyselyn suunnitelman:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>EXPLAIN QUERY PLAN SELECT K.nimi, O.nimi FROM Kurssit K, Opettajat O WHERE K.opettaja_id = O.id;
0|0|0|SCAN TABLE Kurssit AS K
0|1|1|SEARCH TABLE Opettajat AS O USING INTEGER PRIMARY KEY (rowid=?)
</code></pre></div></div>

<p>Tämä kysely käy läpi taulun <code class="language-html highlighter-rouge">Kurssit</code> rivit (<code class="language-html highlighter-rouge">SCAN TABLE Kurssit</code>) ja hakee tietoa taulusta <code class="language-html highlighter-rouge">Opettajat</code> pääavaimen avulla (<code class="language-html highlighter-rouge">SEARCH TABLE Opettajat</code>). Jälkimmäinen tarkoittaa, että kun käsittelyssä on tietty taulun <code class="language-html highlighter-rouge">Kurssit</code> rivi, kysely hakee <em>tehokkaasti</em> taulusta <code class="language-html highlighter-rouge">Opettajat</code> rivin, jossa pääavain <code class="language-html highlighter-rouge">O.id</code> on sama kuin <code class="language-html highlighter-rouge">K.opettaja_id</code>.</p>

<p>Mutta miten käytännössä taulusta <code class="language-html highlighter-rouge">Opettajat</code> voi hakea tehokkaasti? Tämä onnistuu käyttämällä indeksiä, joihin tutustumme heti seuraavaksi.</p>

<h2 id="indeksit">Indeksit</h2>

<p><em>Indeksi</em> on tietokannan taulun yhteyteen tallennettu hakemistorakenne, jonka tavoitteena on tehostaa tauluun liittyvien kyselyiden suorittamista. Indeksin avulla tietokantajärjestelmä voi selvittää tehokkaasti, missä päin taulua on rivejä, jotka täsmäävät tiettyyn hakuehtoon.</p>

<p>Indeksiä voi ajatella samalla tavalla kuin kirjan lopussa olevaa hakemistoa, jossa kerrotaan hakusanoista, millä kirjan sivuilla ne esiintyvät. Hakemiston avulla löydämme tietyn sanan sijainnit paljon nopeammin kuin lukemalla koko kirjan läpi.</p>

<h3 id="pääavaimen-indeksi">Pääavaimen indeksi</h3>

<p>Kun tietokantaan luodaan taulu, sen pääavain saa automaattisesti indeksin. Tämän seurauksena voimme suorittaa tehokkaasti hakuja, joissa ehto liittyy pääavaimeen.</p>

<p>Esimerkiksi kun luomme SQLitessä taulun</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="n">nimi</span> <span class="nb">TEXT</span><span class="p">,</span> <span class="n">hinta</span> <span class="nb">INTEGER</span><span class="p">);</span>
</code></pre></div></div>

<p>niin taululle luodaan indeksi sarakkeelle <code class="language-html highlighter-rouge">id</code> ja voimme etsiä tehokkaasti tuotteita id-numeron perusteella. Tämän ansiosta esimerkiksi seuraava kysely toimii tehokkaasti:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">hinta</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">WHERE</span> <span class="n">id</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
</code></pre></div></div>

<p>Voimme varmistaa tämän kysymällä kyselyn suunnitelman:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>EXPLAIN QUERY PLAN SELECT hinta FROM Tuotteet WHERE id=3;
selectid    order       from        detail                                                   
----------  ----------  ----------  ---------------------------------------------------------
0           0           0           SEARCH TABLE Tuotteet USING INTEGER PRIMARY KEY (rowid=?)
</code></pre></div></div>

<p>Suunnitelmassa näkyy <code class="language-html highlighter-rouge">SEARCH TABLE</code>, mikä tarkoittaa, että kysely pystyy hakemaan taulusta tietoa tehokkaasti indeksin avulla.</p>

<h3 id="indeksin-luominen">Indeksin luominen</h3>

<p>Pääavaimen indeksi on kätevä, mutta voimme haluta myös etsiä tietoa jonkin muun sarakkeen perusteella. Esimerkiksi seuraava kysely hakee rivit sarakkeen <code class="language-html highlighter-rouge">hinta</code> perusteella:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">SELECT</span> <span class="n">nimi</span> <span class="k">FROM</span> <span class="n">Tuotteet</span> <span class="k">WHERE</span> <span class="n">hinta</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
</code></pre></div></div>

<p>Tämä kysely <em>ei</em> ole oletuksena tehokas, koska sarakkeelle <code class="language-html highlighter-rouge">hinta</code> ei ole indeksiä. Näemme tämän pyytämällä taas selitystä kyselystä:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>EXPLAIN QUERY PLAN SELECT nimi FROM Tuotteet WHERE hinta=4;
selectid    order       from        detail             
----------  ----------  ----------  -------------------
0           0           0           SCAN TABLE Tuotteet
</code></pre></div></div>

<p>Nyt suunnitelmassa näkyy <code class="language-html highlighter-rouge">SCAN TABLE</code>, mikä tarkoittaa, että kysely joutuu käymään läpi taulun kaikki rivit. Tämä on hidasta, jos taulussa on paljon rivejä.</p>

<p>Voimme kuitenkin luoda uuden indeksin, joka tehostaa saraketta <code class="language-html highlighter-rouge">hinta</code> käyttäviä kyselyitä. Saamme luotua indeksin komennolla <code class="language-html highlighter-rouge">CREATE INDEX</code> näin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_hinta</span> <span class="k">ON</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">hinta</span><span class="p">);</span>
</code></pre></div></div>

<p>Tässä <code class="language-html highlighter-rouge">idx_hinta</code> on indeksin nimi, jolla voimme viitata siihen myöhemmin. Indeksi toimii luonnin jälkeen täysin automaattisesti, eli tietokantajärjestelmä osaa käyttää sitä kyselyissä
ja huolehtii sen päivittämisestä.</p>

<p>Indeksin luomisen jälkeen voimme kysyä uudestaan kyselyn suunnitelmaa:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>EXPLAIN QUERY PLAN SELECT nimi FROM Tuotteet WHERE hinta=4;
selectid    order       from        detail                                               
----------  ----------  ----------  -----------------------------------------------------
0           0           0           SEARCH TABLE Tuotteet USING INDEX idx_hinta (hinta=?)
</code></pre></div></div>

<p>Indeksin ansiosta suunnitelmassa ei lue enää <code class="language-html highlighter-rouge">SCAN TABLE</code> vaan <code class="language-html highlighter-rouge">SEARCH TABLE</code>. Suunnitelmassa näkyy myös, että aikomuksena on hyödyntää indeksiä <code class="language-html highlighter-rouge">idx_hinta</code>.</p>

<h3 id="lisää-käyttötapoja">Lisää käyttötapoja</h3>

<p>Voimme käyttää indeksiä myös kyselyissä, joissa haemme pienempiä tai suurempia arvoja. Esimerkiksi sarakkeelle <code class="language-html highlighter-rouge">hinta</code> luodun indeksin avulla voimme etsiä vaikkapa rivejä, joille pätee ehto <code class="language-html highlighter-rouge">hinta<span class="nt">&lt;3</span></code> tai <code class="language-html highlighter-rouge">hinta&gt;=8</code>.</p>

<p>Indeksi on myös mahdollista luoda <em>usean</em> sarakkeen perusteella. Esimerkiksi voisimme luoda indeksin näin:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_hinta</span> <span class="k">ON</span> <span class="n">Tuotteet</span> <span class="p">(</span><span class="n">hinta</span><span class="p">,</span><span class="n">nimi</span><span class="p">);</span>
</code></pre></div></div>

<p>Tässä indeksissä rivit on järjestetty ensisijaisesti hinnan ja toissijaisesti nimen mukaan.
Indeksi tehostaa hakuja, joissa hakuperusteena on joko pelkkä hinta tai yhdessä hinta ja nimi. Kuitenkaan indeksi ei tehosta hakuja, joissa hakuperusteena on pelkkä nimi.</p>

<h3 id="miten-indeksi-toimii">Miten indeksi toimii?</h3>

<p>Indeksi tarvitsee tuekseen hakemistorakenteen, josta voi hakea tehokkaasti rivejä sarakkeen
arvon perusteella. Tämä voidaan toteuttaa esimerkiksi puurakenteena, jonka avaimina on sarakkeiden arvoja.</p>

<p>Asiaan liittyvää teoriaa käsitellään tarkemmin kurssilla <em>Tietorakenteet ja algoritmit</em> binäärihakupuiden yhteydessä. Tyypillisiä tietokantojen yhteydessä käytettäviä puurakenteita ovat B-puu ja sen muunnelmat.</p>

<h3 id="milloin-luoda-indeksi">Milloin luoda indeksi?</h3>

<p>Periaatteessa voisi ajatella, että taulun jokaiselle sarakkeelle kannattaa luoda indeksi, jolloin monenlaiset kyselyt ovat nopeita. Tämä ei ole kuitenkaan käytännössä hyvä idea.</p>

<p>Vaikka indeksit tehostavat kyselyitä, niissä on myös kaksi ongelmaa: indeksin hakemistorakenne vie tilaa ja indeksi myös hidastaa tiedon lisäämistä ja muuttamista. Jälkimmäinen johtuu siitä,
että kun taulun sisältö muuttuu, niin muutos täytyy myös päivittää kaikkiin tauluun liittyviin indekseihin. Indeksiä ei siis kannata luoda huvin vuoksi.</p>

<p>Hyvä syy indeksin luontiin on, että haluamme suorittaa usein tietynlaisia kyselyitä ja ne toimivat hitaasti, koska tietokantajärjestelmä joutuu käymään läpi turhaan jonkin taulun kaikki rivit kyselyn aikana. Tällöin voimme lisätä taululle indeksin, jonka avulla tällaiset kyselyt toimivat jatkossa tehokkaasti.</p>

<p>Indekseillä on käytännössä suuri vaikutus tietokantojen tehokkuuteen. Moni tietokanta toimii hitaasti sen takia, että siitä puuttuu oleellisia indeksejä.</p>

<p>Huomaa, että indeksit ovat myös yksi esimerkki siitä, miten toisteinen tieto voi tehostaa kyselyjä. Indekseissä kuitenkaan toisteista tietoa ei tallenneta tauluun vaan
taulun ulkopuolelle erilliseen hakemistorakenteeseen.</p>

<h1 id="8-tietokantojen-teoria">8. Tietokantojen teoria</h1>

<p>Tietokannan sisällön esittäminen relaatiomallin mukaisesti tauluina ja riveinä tuntuu nykyään lähes itsestään selvältä tavalta, mutta tämä oli aikoinaan mullistava idea tietokanta-alalla. Tässä luvussa tutustumme relaatiomallin matemaattiseen taustaan, joka syntyi 1970-luvulla.</p>

<h2 id="matemaattinen-tausta">Matemaattinen tausta</h2>

<h3 id="joukko">Joukko</h3>

<p><em>Joukko</em> (<em>set</em>) on kokoelma alkioita. Esimerkiksi \(A=\{1,2,3,4,5\}\) ja \(B=\{apina, banaani, cembalo\}\) ovat joukkoja.</p>

<p>Merkintä \(\mid S \mid\) tarkoittaa joukon \(S\) alkioiden määrää. Äskeisessä esimerkissä \(\mid A \mid=5\) ja \(\mid B \mid =3\).</p>

<p>Merkintä \(x \in S\) tarkoittaa, että alkio \(x\) kuuluu joukkoon \(S\).</p>

<p>Joukon alkioilla ei ole tiettyä järjestystä. Esimerkiksi \(\{1,2,3\}\), \(\{1,3,2\}\) ja \(\{2,3,1\}\) tarkoittavat samaa joukkoa.</p>

<p>Tietty alkio voi esiintyä joukossa enintään kerran. Esimerkiksi \(\{1,2,1\}\) ei ole joukko, koska alkio \(1\) esiintyy kahdesti.</p>

<h3 id="osajoukko">Osajoukko</h3>

<p><em>Osajoukko</em> (<em>subset</em>) sisältää osan joukon alkioista. Esimerkiksi joukon \(\{1,2,3\}\) osajoukot ovat \(\emptyset\), \(\{1\}\), \(\{2\}\), \(\{3\}\), \(\{1,2\}\), \(\{1,3\}\), \(\{2,3\}\) ja \(\{1,2,3\}\). Merkintä \(\emptyset\) tarkoittaa tyhjää joukkoa.</p>

<p>Merkintä \(A \subset B\) tarkoittaa, että joukko \(A\) on joukon \(B\) osajoukko.</p>

<p>Osajoukko on <em>aito</em> (<em>proper</em>), jos siinä ei ole kaikkia joukon alkioita.</p>

<p>Kun joukossa on \(n\) alkiota, siitä voidaan muodostaa \(2^n\) osajoukkoa. Esimerkiksi joukossa \(\{1,2,3\}\) on \(3\) alkiota, joten osajoukkoja on \(2^3=8\).</p>

<h3 id="monikko">Monikko</h3>

<p><em>Monikko</em> (<em>tuple</em>) on lista alkioita tietyssä järjestyksessä. Esimerkiksi \((1,3,2)\) on monikko, jossa on \(3\) alkiota.</p>

<p>Monikossa alkioiden järjestyksellä on merkitystä. Esimerkiksi \((1,2,3)\), \((1,3,2)\) ja \((2,3,1)\) ovat kolme eri monikkoa.</p>

<p>Monikossa sama alkio voi toistua monta kertaa. Esimerkiksi \((1,2,1)\) on monikko, jossa toistuu kahdesti alkio \(1\).</p>

<h3 id="karteesinen-tulo">Karteesinen tulo</h3>

<p><em>Karteesinen tulo</em> (<em>Cartesian product</em>) \(S_1 \times S_2 \times \dots \times S_k\) sisältää kaikki monikot, jotka muodostuvat valitsemalla järjestyksessä yksi alkio jokaisesta joukosta \(S_1,S_2,\dots,S_k\).</p>

<p>Kun \(A=\{1,2,3\}\) ja \(B=\{x,y,z\}\), niin</p>

\[A \times B = \{(1,x),(1,y),(1,z),(2,x),(2,y),(2,z),(3,x),(3,y),(3,z)\}.\]

<p>Kun \(A=\{1,2,3\}\), \(B=\{x\}\) ja \(C=\{1,2\}\), niin</p>

\[A \times B \times C = \{(1,x,1), (1,x,2), (2,x,1), (2,x,2), (3,x,1), (3,x,2)\}.\]

<p>Karteesisen tulon alkioiden määrä on \(\mid S_1 \mid \cdot \mid S_2 \mid \dots \mid S_k \mid\). Esimerkiksi kun \(\mid A \mid = 3\), \(\mid B \mid = 1\) ja \(\mid C \mid = 2\), karteesinen tulo \(A \times B \times C\) muodostuu \(3 \cdot 1 \cdot 2 = 6\) alkiosta.</p>

<h3 id="relaatio">Relaatio</h3>

<p><em>Relaatio</em> (<em>relation</em>) on karteesisen tulon osajoukko. Kun \(A=\{1,2,3\}\) ja \(B=\{x,y,z\}\), niin mahdollisia karteesisen tulon \(A \times B\) relaatioita ovat esimerkiksi seuraavat:</p>

\[R_1 = \{(1,x),(1,y),(1,z)\}\]

\[R_2 = \{(1,x),(2,x),(2,z),(3,y)\}\]

\[R_3 = \{(2,y)\}\]

<p>Relaatio tarkoittaa siis sitä, että valitaan jokin osajoukko kaikista mahdollisista alkioiden muodostamista yhdistelmistä.</p>

<p>Karteesisella tulolla \(S_1 \times S_2 \times \dots \times S_k\) on kaikkiaan \(2^{\mid S_1 \mid \cdot \mid S_2 \mid \dots \mid S_k \mid}\) mahdollista relaatiota.</p>

<h2 id="taulu-relaationa">Taulu relaationa</h2>

<p>Tietokannan taulu voidaan esittää matemaattisesti relaationa, jonka jokainen monikko vastaa yhtä taulun riviä. Kun taulussa on \(k\) saraketta, relaatiossa jokaisessa monikossa on vastaavasti \(k\) alkiota, joista käytetään nimeä attribuutti. Relaation taustalla on karteesinen tulo</p>

\[S_1 \times S_2 \times \dots \times S_k,\]

<p>jossa joukot \(S_1,S_2,\dots,S_k\) ilmaisevat, mitä arvoja kussakin attribuutissa voi olla eli kunkin attribuutin tyypin.</p>

<h3 id="esimerkki-11">Esimerkki</h3>

<p>Tarkastellaan esimerkkinä taulua <code class="language-html highlighter-rouge">Tuotteet</code>, jossa on tietoa tuotteista:</p>

<table class="db-table">
<thead>
  <tr><th colspan="3" id="table-title">Tuotteet</th></tr>
  <tr><th width="30">id</th><th width="100">nimi</th><th width="70">hinta</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>retiisi</td><td>7</td></tr>
  <tr><td>2</td><td>porkkana</td><td>5</td></tr>
  <tr><td>3</td><td>nauris</td><td>4</td></tr>
  <tr><td>4</td><td>lanttu</td><td>8</td></tr>
  <tr><td>5</td><td>selleri</td><td>4</td></tr>
</tbody>
</table>

<p>Tämä taulu vastaa relaatiota</p>

\[T=\{(1,retiisi,7),(2,porkkana,5),(3,nauris,4),(4,lanttu,8),(5,selleri,4)\},\]

<p>jonka jokainen monikko muodostuu kolmesta attribuutista <code class="language-html highlighter-rouge">id</code>, <code class="language-html highlighter-rouge">nimi</code> ja <code class="language-html highlighter-rouge">hinta</code>.</p>

<p>Tässä tapauksessa relaation taustalla on karteesinen tulo \(S_1 \times S_2 \times S_3\). Joukot \(S_1,S_2,S_3\) määrittelevät attribuuttien tyypit eli jokainen joukko sisältää kaikki arvot, joita vastaavassa attribuutissa voi olla.</p>

<p>Esimerkiksi attribuutti <code class="language-html highlighter-rouge">id</code> on positiivinen kokonaisluku, joten \(S_1\) voisi olla \(\{1,2,3,\dots\}\) eli ääretön joukko, joka sisältää kaikki positiiviset kokonaisluvut. Toinen mahdollisuus on, että id-numerolla on yläraja, kuten yleensä käytännön tietokannoissa. Esimerkiksi jos id-numero on 64-bittinen kokonaisluku, \(S_1\) voisi olla \(\{1,2,3,\dots,2^{64}-1\}\).</p>

<h3 id="teoria-vs-käytäntö">Teoria vs. käytäntö</h3>

<p>SQL-tietokannat perustuvat relaatiomalliin, mutta ne eivät kuitenkaan täysin noudata sitä.</p>

<p>Yksi ero on, että relaatiossa jokainen monikko on erilainen (koska relaatio on joukko), mutta SQL-taulussa ei ole tätä rajoitusta. Esimerkiksi voimme luoda seuraavasti taulun <code class="language-html highlighter-rouge">Testi</code> ja lisätä siihen kolme samanlaista riviä:</p>

<div class="language-prompt highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">sqlite&gt; </span>CREATE TABLE Testi (x INTEGER);
<span class="p">sqlite&gt; </span>INSERT INTO Testi VALUES (1);
<span class="p">sqlite&gt; </span>INSERT INTO Testi VALUES (1);
<span class="p">sqlite&gt; </span>INSERT INTO Testi VALUES (1);
<span class="p">sqlite&gt; </span>SELECT * FROM Testi;
1
1
1
</code></pre></div></div>

<p>Usein tosin SQL-taulussa on sarake <code class="language-html highlighter-rouge">id</code>, joka takaa, että taulussa ei ole kahta samanlaista riviä, koska jokaisella rivillä on eri id-numero.</p>

<p>Toinen ero on, että relaatiossa jokaisella monikon attribuutilla tulee olla arvo mutta SQL-taulussa sarakkeessa voi olla <code class="language-html highlighter-rouge">NULL</code> eli arvo puuttuu.</p>

<h2 id="relaatio-operaatiot">Relaatio-operaatiot</h2>

<p>Relaatio-operaatioiden avulla olemassa olevista relaatioista voidaan muodostaa uusi relaatio. Tämä vastaa SQL:ssä kyselyä, jossa tauluista muodostetaan tulostaulu. Tutustumme seuraavaksi esimerkkinä kolmeen keskeiseen relaatio-operaatioon: projektio, restriktio ja liitos.</p>

<h3 id="projektio">Projektio</h3>

<p>Projektio \(\Pi\) muodostaa relaation, jossa monikoista valitaan tietyt attribuutit. Projektio vastaa SQL-kyselyä, jossa valitaan tietyt sarakkeet taulusta. Esimerkiksi projektio \(\Pi_{nimi,hinta}(T)\) vastaa SQL-kyselyä <code class="language-html highlighter-rouge">SELECT nimi, hinta FROM Tuotteet</code>.</p>

<p>Esimerkkejä:</p>

\[\Pi_{nimi}(T) = \{(retiisi),(porkkana),(nauris),(lanttu),(selleri)\}\]

\[\Pi_{hinta}(T) = \{(7),(5),(4),(8)\}\]

\[\Pi_{nimi,hinta}(T) = \{(retiisi,7),(porkkana,5),(nauris,4),(lanttu,8),(selleri,4)\}\]

<p>Huomaa, että mahdolliset toistuvat monikot suodattuvat pois projektiosta. Tämän takia projektiossa \(\Pi_{hinta}(T)\) on vain neljä monikkoa, koska kahdella tuotteella on sama hinta.</p>

<h3 id="restriktio">Restriktio</h3>

<p>Restriktio \(\sigma\) muodostaa relaation, jossa on tietyt ehdot täyttävät monikot. Restriktio vastaa SQL-kyselyä, jossa rivit valitaan <code class="language-html highlighter-rouge">WHERE</code>-osassa. Esimerkiksi restriktio \(\sigma_{hinta \le 5}(T)\) vastaa SQL-kyselyä <code class="language-html highlighter-rouge">SELECT * FROM Tuotteet WHERE hinta <span class="nt">&lt;</span><span class="err">=</span> <span class="na">5</span></code>.</p>

<p>Esimerkkejä:</p>

\[\sigma_{nimi = nauris}(T)=\{(3,nauris,4)\}\]

\[\sigma_{hinta = 4}(T)=\{(3,nauris,4),(5,selleri,4)\}\]

\[\sigma_{hinta \le 5}(T)=\{(2,porkkana,5),(3,nauris,4),(5,selleri,4)\}\]

<p>Yhdistämällä projektio ja restriktio saadaan vastine esimerkiksi SQL-kyselylle <code class="language-html highlighter-rouge">SELECT nimi FROM Tuotteet WHERE hinta <span class="nt">&lt;</span><span class="err">=</span> <span class="na">5</span></code>:</p>

\[\Pi_{nimi}(\sigma_{hinta \le 5}(T))=\{(porkkana),(nauris),(selleri)\}\]

<h3 id="liitos">Liitos</h3>

<p>Liitos \(\bowtie\) muodostaa relaation, jonka monikot on koostettu kahden relaation pohjalta. Tämä vastaa SQL:ssä kahden taulun kyselyä.</p>

<p>Tarkastellaan esimerkkinä seuraavia tauluja <code class="language-html highlighter-rouge">Henkilot</code> ja <code class="language-html highlighter-rouge">Yritykset</code>:</p>

<table class="db-table">
<thead>
  <tr><th colspan="3" id="table-title">Henkilot</th></tr>
  <tr><th width="30">id</th><th width="100">nimi</th><th width="70">yritys_id</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>Maija</td><td>1</td></tr>
  <tr><td>2</td><td>Liisa</td><td>1</td></tr>
  <tr><td>3</td><td>Kaaleppi</td><td>3</td></tr>
</tbody>
</table>

<table class="db-table">
<thead>
  <tr><th colspan="3" id="table-title">Yritykset</th></tr>
  <tr><th width="30">id</th><th width="100">nimi</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>Google</td></tr>
  <tr><td>2</td><td>Amazon</td></tr>
  <tr><td>3</td><td>Facebook</td></tr>
</tbody>
</table>

<p>Näitä tauluja vastaavat seuraavat relaatiot:</p>

\[H = \{(1,Maija,1),(2,Liisa,1),(3,Kaaleppi,3)\}\]

\[Y = \{(1,Google),(2,Amazon),(3,Facebook)\}\]

<p>Nyt kyselyä <code class="language-html highlighter-rouge">SELECT * FROM Henkilot H, Yritykset Y WHERE H.yritys_id = Y.id</code> vastaa seuraava relaatio-operaatio:</p>

\[{H\ \bowtie\ Y \atop \small H.yritys\_id = Y.id} = \{(1,Maija,1,1,Google),(2,Liisa,1,1,Google),(3,Kaaleppi,3,3,Facebook)\}\]

<p>Yhdistämällä tähän projektion saamme haettua kunkin henkilön nimen ja yrityksen nimen:</p>

\[\Pi_{H.nimi,Y.nimi}({H\ \bowtie\ Y \atop \small H.yritys\_id = Y.id}) = \{(Maija,Google),(Liisa,Google),(Kaaleppi,Facebook)\}\]

<h3 id="teoria-vs-käytäntö-1">Teoria vs. käytäntö</h3>

<p>Relaatio-operaatioiden avulla voidaan toteuttaa hakuja samaan tapaan kuin SQL-kyselyillä, mutta tässäkin SQL-kielessä on joitakin eroja.</p>

<p>Kuten näimme aiemmin, projektio \(\Pi_{hinta}(T)\) sisältää jokaisen eri hinnan vain kerran, kun taas kyselyn <code class="language-html highlighter-rouge">SELECT hinta FROM Tuotteet</code> tulostaulussa voi olla monta kertaa sama hinta. SQL:ssä on itse asiassa kaksi eri tapaa hakea tietoa:</p>

<ul>
  <li><code class="language-html highlighter-rouge">SELECT ALL ...</code>: haetaan kaikki rivit, myös toistuvat rivit</li>
  <li><code class="language-html highlighter-rouge">SELECT DISTINCT ...</code>: haetaan jokainen erilainen rivi vain kerran</li>
</ul>

<p>Ensimmäinen tapa on oletus ja sanaa <code class="language-html highlighter-rouge">ALL</code> ei käytetä yleensä, mutta toistuvat rivit voidaan poistaa sanan <code class="language-html highlighter-rouge">DISTINCT</code> avulla. Tarkasti ottaen projektiota \(\Pi_{hinta}(T)\) vastaa siis kysely <code class="language-html highlighter-rouge">SELECT DISTINCT hinta FROM Tuotteet</code>.</p>

<p>Lisäksi SQL:ssä rivien järjestyksellä voi olla väliä, kun taas relaation monikoilla ei ole järjestystä. Rivien järjestys näkyy SQL:ssä esimerkiksi kyselyssä, jonka lopussa on <code class="language-html highlighter-rouge">ORDER BY</code>, jolloin tulostaulun rivit ovat halutussa järjestyksessä. Relaatio-operaatioilla ei ole mahdollista toteuttaa tällaista hakua.</p>

<h2 id="avaimet-ja-riippuvuudet">Avaimet ja riippuvuudet</h2>

<p><em>Yliavain</em> (<em>superkey</em>) on attribuuttien yhdistelmä, joka on varmasti erilainen jokaisessa relaation monikossa. Yliavain yksilöi siis jokaisen relaatiossa olevan monikon.</p>

<p><em>Kandidaattiavain</em> (<em>candidate key</em>) eli <em>avain</em> (<em>key</em>) on minimaalinen yliavain. Tämä tarkoittaa, että jos poistetaan mikä tahansa attribuutti, niin kyseessä ei ole enää yliavain.</p>

<p><em>Pääavain</em> (<em>primary key</em>) on yksi avaimista, joka on nostettu erikoisasemaan.</p>

<h3 id="esimerkki-12">Esimerkki</h3>

<p>Tarkastellaan esimerkkinä tuotteita kuvaavaa relaatiota, jonka attribuutit ovat <code class="language-html highlighter-rouge">id</code>, <code class="language-html highlighter-rouge">nimi</code> ja <code class="language-html highlighter-rouge">hinta</code>.</p>

<p>Koska attribuutti <code class="language-html highlighter-rouge">id</code> yksilöi jokaisen monikon, se on yliavain. Myös yhdistelmät (<code class="language-html highlighter-rouge">id</code>, <code class="language-html highlighter-rouge">nimi</code>), (<code class="language-html highlighter-rouge">id</code>, <code class="language-html highlighter-rouge">hinta</code>) ja (<code class="language-html highlighter-rouge">id</code>, <code class="language-html highlighter-rouge">nimi</code>, <code class="language-html highlighter-rouge">hinta</code>) ovat yliavaimia, koska niiden osana on attribuutti <code class="language-html highlighter-rouge">id</code>. Kuitenkin näistä yliavaimista vain <code class="language-html highlighter-rouge">id</code> on avain, koska muut yliavaimet eivät ole minimaalisia.</p>

<p>Attribuutti <code class="language-html highlighter-rouge">hinta</code> ei selkeästi ole yliavain, koska monella tuotteella voi olla sama hinta. Attribuutti <code class="language-html highlighter-rouge">nimi</code> on yliavain siinä tapauksessa, että usealla tuotteella ei voi olla samaa nimeä. Yhdistelmä (<code class="language-html highlighter-rouge">nimi</code>, <code class="language-html highlighter-rouge">hinta</code>) on yliavain, jos ei voi olla kahta tuotetta, joilla olisi sekä sama nimi että sama hinta. Riippuu siis tietoon liittyvistä oletuksista, mitkä attribuuttien yhdistelmät ovat yliavaimia.</p>

<h3 id="avaimen-valinta">Avaimen valinta</h3>

<p>Avain voi olla joko <em>luonnollinen avain</em> (<em>natural key</em>) tai <em>sijaisavain</em> (<em>surrogate key</em>). Luonnollinen avain muodostuu alkuperäisestä tiedosta, kun taas sijaisavain on lisätty mukaan nimenomaan sen takia, että siitä tulisi avain. Esimerkiksi <code class="language-html highlighter-rouge">nimi</code> on luonnollinen avain, kun taas <code class="language-html highlighter-rouge">id</code> on sijaisavain.</p>

<p>Tietokantojen teoriassa näkee usein käytettävän luonnollisia avaimia, mutta käytännössä on hyvin tavallista käyttää id-numeroa tai vastaavaa sijaisavainta. Tässä on etuna, että id-numero on kompakti tieto, joka kelpaa varmasti avaimeksi. Jos valittaisiin luonnollinen avain, siihen kuuluisi ehkä monia attribuutteja ja pitäisi pohtia, riittävätkö attribuutit varmasti yksilöimään monikon kaikissa tapauksissa.</p>

<h3 id="funktionaalinen-riippuvuus">Funktionaalinen riippuvuus</h3>

<p><em>Funktionaalinen riippuvuus</em> (<em>functional dependency</em>) \(A \to B\) tarkoittaa, että attribuutit \(A\) määräävät attribuutit \(B\). Toisin sanoen jos relaatiossa on kaksi monikkoa, joissa attribuutit \(A\) ovat samat, niin myös attribuutit \(B\) ovat samat.</p>

<p>Esimerkiksi jos relaatiossa on attribuutit <code class="language-html highlighter-rouge">postinumero</code> ja <code class="language-html highlighter-rouge">kaupunki</code>, siinä on funktionaalinen riippuvuus <code class="language-html highlighter-rouge">postinumero</code> \(\to\) <code class="language-html highlighter-rouge">kaupunki</code>, koska postinumerosta voidaan päätellä kaupunki. Ei voi olla kahta monikkoa, joissa olisi sama postinumero mutta eri kaupunki.</p>

<p>Attribuutit \(A\) muodostavat yliavaimen tarkalleen silloin, kun \(A \to B\) pätee mille tahansa attribuuteille \(B\). Tässä tapauksessa koska \(A\) on yliavain, relaatiossa ei voi olla kahta monikkoa, jossa attribuutit \(A\) ovat samat.</p>

<h2 id="normaalimuodot">Normaalimuodot</h2>

<p>Normaalimuodot ovat tietokannan suunnitteluun liittyviä vaatimuksia, joiden tavoitteena on edistää tiedon eheyttä ja helpottaa tietokannan käyttämistä.</p>

<p>Ensimmäinen normaalimuoto vaatii, että tietokannassa on käytössä relaatiomalli. SQL:ssä määritelty taulu toteuttaa automaattisesti ensimmäisen normaalimuodon.</p>

<p>Toinen ja kolmas normaalimuoto liittyvät attribuuttien riippuvuuksiin. Näiden pohjalta on edelleen kehitetty Boyce–Codd-normaalimuoto, johon tutustumme seuraavaksi.</p>

<h3 id="boycecodd-normaalimuoto">Boyce–Codd-normaalimuoto</h3>

<p>Relaatio toteuttaa Boyce–Codd-normaalimuodon, jos jokaisessa siinä olevassa funktionaalisessa riippuvuudessa \(X \to Y\) pätee, että \(Y \subset X\) tai \(X\) on yliavain.</p>

<p>Ideana on varmistaa, että relaatiossa ei ole riippuvuuksia, jotka eivät liittyisi relaation avaimiin. Jos tällaisia riippuvuuksia on olemassa, ne tulisi esittää erillisessä relaatiossa.</p>

<p>Jos \(Y \subset X\), niin attribuutit \(Y\) ovat osa attribuutteja \(X\). Tällainen riippuvuus on voimassa aina, eli se ei kerro mitään erityistä. Esimerkki tästä on riippuvuus (<code class="language-html highlighter-rouge">nimi</code>, <code class="language-html highlighter-rouge">hinta</code>) \(\to\) <code class="language-html highlighter-rouge">hinta</code>.</p>

<p>Jos \(X\) on yliavain, niin riippuvuus \(X \to Y\) kuuluu asiaan, koska yliavain määrää kaikki attribuutit. Esimerkki tästä on riippuvuus <code class="language-html highlighter-rouge">id</code> \(\to\) <code class="language-html highlighter-rouge">nimi</code>.</p>

<p>Jos relaatio toteuttaa Boyce–Codd-normaalimuodon, niin se toteuttaa myös ensimmäisen, toisen ja kolmannen normaalimuodon.</p>

<h3 id="esimerkki-13">Esimerkki</h3>

<p>Tarkastellaan esimerkkinä seuraavaa taulua <code class="language-html highlighter-rouge">Suoritukset</code>, jossa on kurssisuorituksia:</p>

<table class="db-table">
<thead>
  <tr><th colspan="4" id="table-title">Suoritukset</th></tr>
  <tr><th width="30">id</th><th width="100">opiskelija_id</th><th width="100">kurssi_id</th><th width="100">op</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>123123</td><td>111</td><td>5</td></tr>
  <tr><td>2</td><td>321321</td><td>111</td><td>5</td></tr>
  <tr><td>3</td><td>123123</td><td>222</td><td>10</td></tr>
  <tr><td>4</td><td>321321</td><td>333</td><td>5</td></tr>
</tbody>
</table>

<p>Oletetaan, että jokaisella kurssilla on kiinteä opintopisteiden määrä, jolloin taulussa on riippuvuus <code class="language-html highlighter-rouge">kurssi_id</code> \(\to\) <code class="language-html highlighter-rouge">op</code>. Tämä on vastoin Boyce–Codd-normaalimuotoa, koska sarake <code class="language-html highlighter-rouge">op</code> ei ole osa saraketta <code class="language-html highlighter-rouge">kurssi_id</code> eikä sarake <code class="language-html highlighter-rouge">kurssi_id</code> ole yliavain.</p>

<p>Asia voidaan korjata tallentamalla kurssien opintopisteet erilliseen tauluun:</p>

<table class="db-table">
<thead>
  <tr><th colspan="3" id="table-title">Suoritukset</th></tr>
  <tr><th width="30">id</th><th width="100">opiskelija_id</th><th width="100">kurssi_id</th></tr>
</thead>
<tbody>
  <tr><td>1</td><td>123123</td><td>111</td></tr>
  <tr><td>2</td><td>321321</td><td>111</td></tr>
  <tr><td>3</td><td>123123</td><td>222</td></tr>
  <tr><td>4</td><td>321321</td><td>333</td></tr>
</tbody>
</table>

<table class="db-table">
<thead>
  <tr><th colspan="2" id="table-title">Kurssit</th></tr>
  <tr><th width="50">id</th><th width="100">op</th></tr>
</thead>
<tbody>
  <tr><td>111</td><td>5</td></tr>
  <tr><td>222</td><td>10</td></tr>
  <tr><td>333</td><td>5</td></tr>
</tbody>
</table>

<p>Tämän muutoksen jälkeen molemmat taulut noudattavat Boyce–Codd-normaalimuotoa.</p>

<h3 id="teoria-vs-käytäntö-2">Teoria vs. käytäntö</h3>

<p>Normaalimuotojen merkityksenä on, että ne antavat matemaattisen näkökulman tietokantojen suunnitteluun. Esimerkiksi jos tietokanta ei toteuta Boyce–Codd-normaalimuotoa, tietokannan rakennetta voi luultavasti parantaa.</p>

<p>Käytännössä tietokantoja ei kuitenkaan yleensä suunnitella normaalimuotojen avulla vaan luvun 6 periaatteiden tyylisesti. Normaalimuodot kuvaavat osan siitä, millainen ajattelutapa on pätevällä tietokantojen suunnittelijalla.</p>


</div>
        <div class="footer">
    <img src=/syksy-2023/assets/img/HY_logo.png>
    </div>
    </div>
</body>

</html>